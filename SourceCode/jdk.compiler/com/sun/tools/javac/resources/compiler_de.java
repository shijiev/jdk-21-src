package com.sun.tools.javac.resources;

public final class compiler_de extends java.util.ListResourceBundle {
    protected final Object[][] getContents() {
        return new Object[][] {
            { "compiler.err.abstract.cant.be.accessed.directly", "{0} {1} in {2} ist abstrakt und kann nicht direkt aufgerufen werden" },
            { "compiler.err.abstract.cant.be.instantiated", "{0} ist abstrakt, kann nicht instanziiert werden" },
            { "compiler.err.abstract.meth.cant.have.body", "Abstrakte Methoden k\u00F6nnen keinen Body enthalten" },
            { "compiler.err.add.exports.with.release", "Export eines Packages aus Systemmodul {0} ist mit --release nicht zul\u00E4ssig" },
            { "compiler.err.add.reads.with.release", "Hinzuf\u00FCgen von Lese-Edges f\u00FCr Systemmodul {0} ist mit --release nicht zul\u00E4ssig" },
            { "compiler.err.addmods.all.module.path.invalid", "--add-modules ALL-MODULE-PATH kann nur beim Kompilieren des unbenannten Moduls oder beim Kompilieren im Kontext eines automatischen Moduls verwendet werden" },
            { "compiler.err.already.annotated", "{0} {1} wurde bereits mit Annotation versehen" },
            { "compiler.err.already.defined", "{0} {1} ist bereits in {2} {3} definiert" },
            { "compiler.err.already.defined.in.clinit", "{0} {1} ist bereits in {2} von {3} {4} definiert" },
            { "compiler.err.already.defined.single.import", "Es wurde bereits ein Typ mit demselben einfachen Namen durch den Einzeltypimport von {0} definiert" },
            { "compiler.err.already.defined.static.single.import", "Es wurde bereits ein Typ mit demselben einfachen Namen durch den statischen Einzeltypimport von {0} definiert" },
            { "compiler.err.already.defined.this.unit", "{0} ist in dieser Kompilierungseinheit bereits definiert" },
            { "compiler.err.annotation.decl.not.allowed.here", "Annotationsschnittstellendeklaration hier nicht zul\u00E4ssig" },
            { "compiler.err.annotation.missing.default.value", "In Annotation @{0} fehlt ein Standardwert f\u00FCr das Element \"{1}\"" },
            { "compiler.err.annotation.missing.default.value.1", "In Annotation @{0} fehlen Standardwerte f\u00FCr Elemente {1}" },
            { "compiler.err.annotation.missing.element.value", "In Annotation fehlt ein Elementwert" },
            { "compiler.err.annotation.not.valid.for.type", "Annotation ist f\u00FCr Element des Typs {0} nicht g\u00FCltig" },
            { "compiler.err.annotation.type.not.applicable", "Annotationsschnittstelle ist f\u00FCr diese Art Deklaration nicht anwendbar" },
            { "compiler.err.annotation.type.not.applicable.to.type", "Annotation @{0} ist in diesem Typkontext nicht anwendbar" },
            { "compiler.err.annotation.unrecognized.attribute.name", "Annotation @{0} weist das unbekannte Attribut \"{1}\" auf" },
            { "compiler.err.annotation.value.must.be.annotation", "Annotationswert muss eine Annotation sein" },
            { "compiler.err.annotation.value.must.be.class.literal", "Annotationswert muss ein Klassenliteral sein" },
            { "compiler.err.annotation.value.must.be.name.value", "Annotationswerte m\u00FCssen das Format \"Name=Wert\" aufweisen" },
            { "compiler.err.annotation.value.not.allowable.type", "Annotationswert hat keinen zul\u00E4ssigen Typ" },
            { "compiler.err.anon.class.impl.intf.no.args", "Anonyme Klasse implementiert Schnittstelle. Argumente sind nicht m\u00F6glich" },
            { "compiler.err.anon.class.impl.intf.no.qual.for.new", "Anonyme Klasse implementiert Schnittstelle. Qualifier f\u00FCr \"Neu\" ist nicht m\u00F6glich" },
            { "compiler.err.anon.class.impl.intf.no.typeargs", "Anonyme Klasse implementiert Schnittstelle. Typargumente sind nicht m\u00F6glich" },
            { "compiler.err.anonymous.diamond.method.does.not.override.superclass", "Methode \u00FCberschreibt oder implementiert keine Methode aus einem Supertyp\n{0}" },
            { "compiler.err.array.and.receiver", "Legacy-Arraynotation f\u00FCr receiver-Parameter nicht zul\u00E4ssig" },
            { "compiler.err.array.and.varargs", "{0} und {1} k\u00F6nnen nicht beide in {2} deklariert werden" },
            { "compiler.err.array.dimension.missing", "Arraydimension fehlt" },
            { "compiler.err.array.req.but.found", "Array erforderlich, aber {0} gefunden" },
            { "compiler.err.assert.as.identifier", "Ab Release 1.4 ist \"assert\" ein Schl\u00FCsselwort und kann nicht als ID verwendet werden" },
            { "compiler.err.attribute.value.must.be.constant", "Elementwert muss ein Konstantenausdruck sein" },
            { "compiler.err.bad.file.name", "Ung\u00FCltiger Dateiname: {0}" },
            { "compiler.err.bad.functional.intf.anno", "Unerwartete @FunctionalInterface-Annotation" },
            { "compiler.err.bad.functional.intf.anno.1", "Unerwartete @FunctionalInterface-Annotation\n{0}" },
            { "compiler.err.bad.initializer", "Ung\u00FCltiger Initializer f\u00FCr {0}" },
            { "compiler.err.bad.name.for.option", "Ung\u00FCltiger Name im Wert f\u00FCr {0}-Option: \"{1}\"" },
            { "compiler.err.bad.value.for.option", "Ung\u00FCltiger Wert f\u00FCr {0}-Option: \"{1}\"" },
            { "compiler.err.break.outside.switch.expression", "Versuch, Vorgang aus einem Switch-Ausdruck zu unterbrechen" },
            { "compiler.err.break.outside.switch.loop", "Unterbrechung au\u00DFerhalb Switch oder Schleife" },
            { "compiler.err.call.must.be.first.stmt.in.ctor", "Aufruf von {0} muss die erste Anweisung im Konstruktor sein" },
            { "compiler.err.call.to.super.not.allowed.in.enum.ctor", "Aufruf von Super in Enum-Konstruktor nicht zul\u00E4ssig" },
            { "compiler.err.cannot.assign.not.declared.guard", "Zuweisen zu {0} nicht m\u00F6glich, da das Element nicht im Guard deklariert wurde" },
            { "compiler.err.cannot.create.array.with.diamond", "Array kann nicht mit \"<>\" erstellt werden" },
            { "compiler.err.cannot.create.array.with.type.arguments", "Array kann nicht mit Typargumenten erstellt werden" },
            { "compiler.err.cannot.generate.class", "Fehler beim Generieren der Klasse {0}\n({1})" },
            { "compiler.err.cant.access", "Kein Zugriff auf {0}\n{1}" },
            { "compiler.err.cant.apply.diamond", "Typargumente f\u00FCr {0} k\u00F6nnen nicht abgeleitet werden" },
            { "compiler.err.cant.apply.diamond.1", "Typargumente f\u00FCr {0} k\u00F6nnen nicht abgeleitet werden\nGrund: {1}" },
            { "compiler.err.cant.apply.symbol", "{0} {1} in {4} {5} kann nicht auf die angegebenen Typen angewendet werden.\nErforderlich: {2}\nErmittelt:    {3}\nGrund: {6}" },
            { "compiler.err.cant.apply.symbol.noargs", "{0} {1} in {2} {3} kann nicht auf die angegebenen Typen angewendet werden.\nGrund: {4}" },
            { "compiler.err.cant.apply.symbols", "{0} f\u00FCr {1}({2}) nicht geeignet" },
            { "compiler.err.cant.assign.val.to.this", "Zuweisen zu \"this\" nicht m\u00F6glich" },
            { "compiler.err.cant.assign.val.to.var", "Der {0}-Variablen {1} kann kein Wert zugewiesen werden" },
            { "compiler.err.cant.deref", "{0} kann nicht dereferenziert werden" },
            { "compiler.err.cant.extend.intf.annotation", "\"extends\" f\u00FCr @interfaces nicht zul\u00E4ssig" },
            { "compiler.err.cant.infer.local.var.type", "Typ f\u00FCr lokale Variable {0} kann nicht abgeleitet werden\n({1})" },
            { "compiler.err.cant.inherit.diff.arg", "{0} kann nicht mit verschiedenen Argumenten geerbt werden: <{1}> und <{2}>" },
            { "compiler.err.cant.inherit.from.anon", "Erben aus anonymer Klasse nicht m\u00F6glich" },
            { "compiler.err.cant.inherit.from.final", "Erben aus finalem {0}-Element nicht m\u00F6glich" },
            { "compiler.err.cant.inherit.from.sealed", "Klasse darf nicht verschl\u00FCsselte Klasse erweitern: {0} (da diese nicht in der \"permits\"-Klausel enthalten ist)" },
            { "compiler.err.cant.read.file", "Lesen nicht m\u00F6glich: {0}" },
            { "compiler.err.cant.ref.before.ctor.called", "{0} kann nicht referenziert werden, bevor der Supertypkonstruktor aufgerufen wurde" },
            { "compiler.err.cant.ref.non.effectively.final.var", "Von {1} referenzierte lokale Variablen m\u00FCssen final oder effektiv final sein" },
            { "compiler.err.cant.resolve", "Symbol nicht gefunden\nSymbol: {0} {1}" },
            { "compiler.err.cant.resolve.args", "Symbol nicht gefunden\nSymbol: {0} {1}({3})" },
            { "compiler.err.cant.resolve.args.params", "Symbol nicht gefunden\nSymbol: {0} <{2}>{1}({3})" },
            { "compiler.err.cant.resolve.location", "Symbol nicht gefunden\nSymbol: {0} {1}\nOrt: {4}" },
            { "compiler.err.cant.resolve.location.args", "Symbol nicht gefunden\nSymbol: {0} {1}({3})\nOrt: {4}" },
            { "compiler.err.cant.resolve.location.args.params", "Symbol nicht gefunden\nSymbol: {0} <{2}>{1}({3})\nOrt: {4}" },
            { "compiler.err.cant.select.static.class.from.param.type", "Statische Klasse kann nicht aus einem parametrisierten Typ ausgew\u00E4hlt werden" },
            { "compiler.err.cant.type.annotate.scoping", "Scoping-Konstrukt kann nicht mit type-use-Annotationen versehen werden: {0}" },
            { "compiler.err.cant.type.annotate.scoping.1", "Scoping-Konstrukt kann nicht mit type-use-Annotation versehen werden: {0}" },
            { "compiler.err.catch.without.try", "\"catch\" ohne \"try\"" },
            { "compiler.err.clash.with.pkg.of.same.name", "{0} {1} steht in Konflikt mit Package desselben Namens" },
            { "compiler.err.class.cant.write", "Fehler beim Schreiben von {0}: {1}" },
            { "compiler.err.class.in.module.cant.extend.sealed.in.diff.module", "Klasse {0} in Modul {1} darf keine verschl\u00FCsselte Klasse in einem anderen Modul erweitern" },
            { "compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package", "Klasse {0} in unbenanntem Modul darf keine verschl\u00FCsselte Klasse in einem anderen Package erweitern" },
            { "compiler.err.class.not.allowed", "Klassen-, Schnittstellen- oder Enum-Deklaration hier nicht zul\u00E4ssig" },
            { "compiler.err.class.public.should.be.in.file", "{0} {1} ist \u00F6ffentlich und muss in einer Datei namens {1}.java deklariert werden" },
            { "compiler.err.concrete.inheritance.conflict", "Methoden {0} von {1} und {2} von {3} werden mit derselben Signatur geerbt" },
            { "compiler.err.conflicting.exports", "Doppelte oder unvereinbare Exporte: {0}" },
            { "compiler.err.conflicting.exports.to.module", "Doppelte oder unvereinbare Exporte in Modul: {0}" },
            { "compiler.err.conflicting.opens", "Doppelte oder unvereinbare \"opens\": {0}" },
            { "compiler.err.conflicting.opens.to.module", "Doppelte oder unvereinbare \"opens\" in Modul: {0}" },
            { "compiler.err.const.expr.req", "Konstantenausdruck erforderlich" },
            { "compiler.err.constant.label.not.compatible", "Konstantes Label des Typs {0} ist nicht mit Switch-Selektortyp {1} kompatibel" },
            { "compiler.err.cont.outside.loop", "Fortsetzung au\u00DFerhalb Schleife" },
            { "compiler.err.continue.outside.switch.expression", "Versuch, Vorgang aus einem Switch-Ausdruck fortzusetzen" },
            { "compiler.err.cyclic.annotation.element", "Typ von Element {0} ist zyklisch" },
            { "compiler.err.cyclic.inheritance", "Zyklische Vererbung mit {0}" },
            { "compiler.err.cyclic.requires", "Zyklische Abh\u00E4ngigkeit mit {0}" },
            { "compiler.err.dc.bad.entity", "Ung\u00FCltige HTML-Entity" },
            { "compiler.err.dc.bad.inline.tag", "Falsche Verwendung von Inlinetag" },
            { "compiler.err.dc.gt.expected", "\">\" erwartet" },
            { "compiler.err.dc.identifier.expected", "ID erwartet" },
            { "compiler.err.dc.invalid.html", "ung\u00FCltige HTML" },
            { "compiler.err.dc.malformed.html", "Nicht wohlgeformte HTML" },
            { "compiler.err.dc.missing.semicolon", "Semikolon fehlt" },
            { "compiler.err.dc.no.content", "kein Inhalt" },
            { "compiler.err.dc.no.tag.name", "Kein Tagname nach \"@\"" },
            { "compiler.err.dc.no.title", "kein Name" },
            { "compiler.err.dc.no.url", "keine URL" },
            { "compiler.err.dc.ref.annotations.not.allowed", "Annotationen nicht zul\u00E4ssig" },
            { "compiler.err.dc.ref.bad.parens", "Unerwarteter Text nach Klammer" },
            { "compiler.err.dc.ref.syntax.error", "Syntaxfehler in Referenz" },
            { "compiler.err.dc.ref.unexpected.input", "Unerwarteter Text" },
            { "compiler.err.dc.unexpected.content", "Unerwarteter Inhalt" },
            { "compiler.err.dc.unterminated.inline.tag", "Nicht abgeschlossenes Inlinetag" },
            { "compiler.err.dc.unterminated.signature", "Nicht abgeschlossene Signatur" },
            { "compiler.err.dc.unterminated.string", "Nicht abgeschlossene Zeichenfolge" },
            { "compiler.err.deconstruction.pattern.only.records", "Dekonstruktionsmuster k\u00F6nnen nur auf Datens\u00E4tze angewendet werden. {0} ist kein Datensatz" },
            { "compiler.err.deconstruction.pattern.var.not.allowed", "Dekonstruktionsmuster k\u00F6nnen nur auf Datens\u00E4tze angewendet werden, \"var\" ist nicht zul\u00E4ssig" },
            { "compiler.err.default.allowed.in.intf.annotation.member", "Standardwert nur in einer Annotationsschnittstellendeklaration zul\u00E4ssig" },
            { "compiler.err.default.label.not.allowed", "Standardlabel hier nicht zul\u00E4ssig" },
            { "compiler.err.default.overrides.object.member", "Standardmethode {0} in {1} {2} setzt ein Mitglied von java.lang.Object au\u00DFer Kraft" },
            { "compiler.err.does.not.override.abstract", "{0} ist nicht abstrakt und setzt die abstrakte Methode {1} in {2} nicht au\u00DFer Kraft" },
            { "compiler.err.doesnt.exist", "Package {0} ist nicht vorhanden" },
            { "compiler.err.dot.class.expected", "\".class\" erwartet" },
            { "compiler.err.duplicate.annotation.invalid.repeated", "Annotation {0} ist keine g\u00FCltige wiederholbare Annotation" },
            { "compiler.err.duplicate.annotation.member.value", "Doppeltes Element \"{0}\" in Annotation @{1}." },
            { "compiler.err.duplicate.annotation.missing.container", "{0} ist keine wiederholbare Annotationsschnittstelle" },
            { "compiler.err.duplicate.case.label", "Doppeltes CASE-Label" },
            { "compiler.err.duplicate.class", "Doppelte Klasse: {0}" },
            { "compiler.err.duplicate.default.label", "Doppeltes Standardlabel" },
            { "compiler.err.duplicate.module", "Doppeltes Modul: {0}" },
            { "compiler.err.duplicate.module.on.path", "Doppeltes Modul in {0}\nModul in {1}" },
            { "compiler.err.duplicate.provides", "Doppelte \"provides\": Service {0}, Implementierung {1}" },
            { "compiler.err.duplicate.requires", "Doppelte \"requires\": {0}" },
            { "compiler.err.duplicate.unconditional.pattern", "Doppeltes nicht bedingtes Muster" },
            { "compiler.err.duplicate.uses", "Doppelte Verwendungen: {0}" },
            { "compiler.err.else.without.if", "\"else\" ohne \"if\"" },
            { "compiler.err.empty.A.argument", "-A erfordert ein Argument. Verwenden Sie \"-Akey\" oder \"-Akey=value\"" },
            { "compiler.err.empty.char.lit", "Leeres Zeichenliteral" },
            { "compiler.err.encl.class.required", "Eine einschlie\u00DFende Instanz mit {0} ist erforderlich" },
            { "compiler.err.enclosing.class.type.non.denotable", "Einschlie\u00DFender Klassentyp: {0}\nist nicht deklarierbar. F\u00FChren Sie das Casting in einen deklarierbaren Typ aus" },
            { "compiler.err.enum.annotation.must.be.enum.constant", "Ein Enum-Annotationswert muss eine Enum-Konstante sein" },
            { "compiler.err.enum.as.identifier", "Ab Release 5 ist \"enum\" ein Schl\u00FCsselwort und kann nicht als ID verwendet werden" },
            { "compiler.err.enum.cant.be.generic", "Enums k\u00F6nnen nicht generisch sein" },
            { "compiler.err.enum.cant.be.instantiated", "Enum-Klassen d\u00FCrfen nicht instanziiert werden" },
            { "compiler.err.enum.constant.expected", "Hier wird eine Enum-Konstante erwartet" },
            { "compiler.err.enum.constant.not.expected", "Hier wird keine Enum-Konstante erwartet" },
            { "compiler.err.enum.label.must.be.enum.constant", "Das CASE-Label einer Enum-Switch-Konstanten muss eine Enumerationskonstante sein" },
            { "compiler.err.enum.label.must.be.unqualified.enum", "Das CASE-Label eines Enum-Switches muss der unqualifizierte Name einer Enumerationskonstante sein" },
            { "compiler.err.enum.no.finalize", "Enums k\u00F6nnen keine Finalisierungsmethoden aufweisen" },
            { "compiler.err.enum.no.subclassing", "Klassen k\u00F6nnen java.lang.Enum nicht direkt erweitern" },
            { "compiler.err.enum.types.not.extensible", "Enum-Klassen sind nicht erweiterbar" },
            { "compiler.err.error", "Fehler: " },
            { "compiler.err.error.reading.file", "Fehler beim Lesen von {0}. {1}" },
            { "compiler.err.error.writing.file", "Fehler beim Schreiben von {0}. {1}" },
            { "compiler.err.except.already.caught", "Ausnahme {0} wurde bereits abgefangen" },
            { "compiler.err.except.never.thrown.in.try", "Ausnahme {0} wird nie im Body der entsprechenden try-Anweisung ausgel\u00F6st" },
            { "compiler.err.expected", "{0} erwartet" },
            { "compiler.err.expected.module", "\"module\" erwartet" },
            { "compiler.err.expected.module.or.open", "\"module\" oder \"open\" erwartet" },
            { "compiler.err.expected.str", "{0} erwartet" },
            { "compiler.err.expected2", "{0} oder {1} erwartet" },
            { "compiler.err.expected3", "{0}, {1} oder {2} erwartet" },
            { "compiler.err.expected4", "{0}, {1}, {2} oder {3} erwartet" },
            { "compiler.err.expression.not.allowable.as.annotation.value", "Ausdruck ist als Annotationswert nicht zul\u00E4ssig" },
            { "compiler.err.extraneous.semicolon", "\u00DCberfl\u00FCssiges Semikolon" },
            { "compiler.err.feature.not.supported.in.source", "{0} wird in -source {1} nicht unterst\u00FCtzt\n(Verwenden Sie -source {2} oder h\u00F6her, um {0} zu aktivieren)" },
            { "compiler.err.feature.not.supported.in.source.plural", "{0} werden in -source {1} nicht unterst\u00FCtzt\n(Verwenden Sie -source {2} oder h\u00F6her, um {0} zu aktivieren)" },
            { "compiler.err.file.not.directory", "Kein Verzeichnis: {0}" },
            { "compiler.err.file.not.file", "Keine Datei: {0}" },
            { "compiler.err.file.not.found", "Datei nicht gefunden: {0}" },
            { "compiler.err.file.patched.and.msp", "Datei sowohl von --patch-module als auch von --module-source-path zug\u00E4nglich, geh\u00F6rt aber in jedem Pfad zu einem anderen Modul: {0}, {1}" },
            { "compiler.err.file.sb.on.source.or.patch.path.for.module", "Datei muss sich im Quellpfad oder im Patchpfad f\u00FCr das Modul befinden" },
            { "compiler.err.final.parameter.may.not.be.assigned", "final-Parameter {0} darf nicht zugewiesen werden" },
            { "compiler.err.finally.without.try", "\"finally\" ohne \"try\"" },
            { "compiler.err.first.statement.must.be.call.to.another.constructor", "Konstruktor ist nicht kanonisch. Daher muss die erste Anweisung einen anderen Konstruktor der Klasse {0} aufrufen" },
            { "compiler.err.flows.through.from.pattern", "Ung\u00FCltiger Fallthrough von einem Muster" },
            { "compiler.err.flows.through.to.pattern", "Ung\u00FCltiger Fallthrough zu einem Muster" },
            { "compiler.err.foreach.not.applicable.to.type", "for-each nicht auf Ausdruckstyp anwendbar\nErforderlich: {1}\nErmittelt:    {0}" },
            { "compiler.err.fp.number.too.large", "Gleitkommazahl zu gro\u00DF" },
            { "compiler.err.fp.number.too.small", "Gleitkommazahl zu klein" },
            { "compiler.err.generic.array.creation", "Erstellung von generischem Array" },
            { "compiler.err.generic.throwable", "Eine generische Klasse darf java.lang.Throwable nicht erweitern" },
            { "compiler.err.guard.has.constant.expression.false", "Dieses CASE-Label hat einen Guard, der ein konstanter Ausdruck mit dem Wert ''false'' ist" },
            { "compiler.err.guard.not.allowed", "Guards sind nur f\u00FCr CASE-Anweisungen mit einem Muster zul\u00E4ssig" },
            { "compiler.err.icls.cant.have.static.decl", "Unzul\u00E4ssige static-Deklaration in innerer Klasse {0}\nModifikator \"static\" ist nur in Konstantenvariablendeklarationen zul\u00E4ssig" },
            { "compiler.err.illegal.argument.for.option", "Unzul\u00E4ssiges Argument f\u00FCr {0}: {1}" },
            { "compiler.err.illegal.array.creation.both.dimension.and.initialization", "Arrayerstellung mit Dimensionsausdruck und Initialisierung ist unzul\u00E4ssig" },
            { "compiler.err.illegal.char", "Unzul\u00E4ssiges Zeichen: \"{0}\"" },
            { "compiler.err.illegal.char.for.encoding", "Nicht zuordenbares Zeichen (0x{0}) f\u00FCr Codierung {1}" },
            { "compiler.err.illegal.combination.of.modifiers", "Unzul\u00E4ssige Kombination aus Modifikatoren: {0} und {1}" },
            { "compiler.err.illegal.default.super.call", "Ung\u00FCltiger Typ-Qualifier {0} in Standardsuperaufruf\n{1}" },
            { "compiler.err.illegal.dot", "\".\" unzul\u00E4ssig" },
            { "compiler.err.illegal.enum.static.ref", "Unzul\u00E4ssige Referenz zu statischem Feld aus Initializer" },
            { "compiler.err.illegal.esc.char", "Unzul\u00E4ssiges Escapezeichen" },
            { "compiler.err.illegal.forward.ref", "Unzul\u00E4ssige Vorw\u00E4rtsreferenz" },
            { "compiler.err.illegal.initializer.for.type", "Unzul\u00E4ssiger Initializer f\u00FCr {0}" },
            { "compiler.err.illegal.line.end.in.char.lit", "Unzul\u00E4ssiges Zeilenende in Zeichenliteral" },
            { "compiler.err.illegal.nonascii.digit", "Unzul\u00E4ssige Nicht-ASCII-Ziffer" },
            { "compiler.err.illegal.parenthesized.expression", "Unzul\u00E4ssiger Ausdruck in Klammern" },
            { "compiler.err.illegal.qual.not.icls", "Unzul\u00E4ssiger Qualifier. {0} ist keine innere Klasse" },
            { "compiler.err.illegal.record.component.name", "Unzul\u00E4ssiger Datensatzkomponentenname {0}" },
            { "compiler.err.illegal.ref.to.restricted.type", "Unzul\u00E4ssige Referenz zu eingeschr\u00E4nktem Typ \"{0}\"" },
            { "compiler.err.illegal.self.ref", "Selbstreferenz in Initializer" },
            { "compiler.err.illegal.start.of.expr", "Unzul\u00E4ssiger Ausdrucksbeginn" },
            { "compiler.err.illegal.start.of.stmt", "Unzul\u00E4ssiger Anweisungsbeginn" },
            { "compiler.err.illegal.start.of.type", "Unzul\u00E4ssiger Typbeginn" },
            { "compiler.err.illegal.static.intf.meth.call", "Unzul\u00E4ssiger statischer Schnittstellenmethodenaufruf\nDer Empf\u00E4ngerausdruck muss durch den Typ-Qualifier \"{0}\" ersetzt werden" },
            { "compiler.err.illegal.text.block.open", "Unzul\u00E4ssige Sequenz f\u00FCr \u00D6ffnungstrennzeichen von Textblock. Zeilenabschlusszeichen fehlt" },
            { "compiler.err.illegal.underscore", "Unzul\u00E4ssiger Unterstrich" },
            { "compiler.err.illegal.unicode.esc", "Unzul\u00E4ssiges Unicode-Escapezeichen" },
            { "compiler.err.import.requires.canonical", "Import erfordert kanonischen Namen f\u00FCr {0}" },
            { "compiler.err.improperly.formed.type.inner.raw.param", "Falsch formatierter Typ. Typargumente f\u00FCr Raw-Typ angegeben" },
            { "compiler.err.improperly.formed.type.param.missing", "Falsch formatierter Typ. Einige Parameter fehlen" },
            { "compiler.err.incomparable.types", "Nicht vergleichbare Typen: {0} und {1}" },
            { "compiler.err.incompatible.diff.ret.same.type", "Typ {0} definiert {1}({2}) mehr als einmal mit nicht verwandten R\u00FCckgabetypen" },
            { "compiler.err.incompatible.thrown.types.in.mref", "Inkompatible ausgel\u00F6ste Typen {0} in Funktionsausdruck" },
            { "compiler.err.incorrect.constructor.receiver.name", "Der Empf\u00E4ngername stimmt nicht mit dem einschlie\u00DFenden \u00E4u\u00DFeren Klassentyp \u00FCberein\nErforderlich: {0}\nErmittelt:    {1}" },
            { "compiler.err.incorrect.constructor.receiver.type", "Der Empf\u00E4ngertyp stimmt nicht mit dem einschlie\u00DFenden \u00E4u\u00DFeren Klassentyp \u00FCberein\nErforderlich: {0}\nErmittelt:    {1}" },
            { "compiler.err.incorrect.number.of.nested.patterns", "Falsche Anzahl verschachtelter Muster\nErforderlich: {0}\nGefunden: {1}" },
            { "compiler.err.incorrect.receiver.name", "Der Empf\u00E4ngername stimmt nicht mit dem einschlie\u00DFenden Klassentyp \u00FCberein\nErforderlich: {0}\nErmittelt:    {1}" },
            { "compiler.err.incorrect.receiver.type", "Der Empf\u00E4ngertyp stimmt nicht mit dem einschlie\u00DFenden Klassentyp \u00FCberein\nErforderlich: {0}\nErmittelt:    {1}" },
            { "compiler.err.initializer.must.be.able.to.complete.normally", "Initializer muss normal abgeschlossen werden k\u00F6nnen" },
            { "compiler.err.initializer.not.allowed", "Initializer in Schnittstellen nicht zul\u00E4ssig" },
            { "compiler.err.instance.initializer.not.allowed.in.records", "Instanz-Initializer in Datens\u00E4tzen nicht zul\u00E4ssig" },
            { "compiler.err.instanceof.reifiable.not.safe", "{0} kann nicht sicher in {1} konvertiert werden" },
            { "compiler.err.int.number.too.large", "Ganzzahl zu gro\u00DF" },
            { "compiler.err.intf.annotation.cant.have.type.params", "Annotationsschnittstelle {0} darf nicht generisch sein" },
            { "compiler.err.intf.annotation.member.clash", "Annotationsschnittstelle {1} deklariert ein Element mit demselben Namen wie Methode {0}" },
            { "compiler.err.intf.annotation.members.cant.have.params", "Elemente in Annotationsschnittstellendeklarationen k\u00F6nnen keine formalen Parameter deklarieren" },
            { "compiler.err.intf.annotation.members.cant.have.type.params", "Elemente in Annotationsschnittstellendeklarationen k\u00F6nnen keine generischen Methoden sein" },
            { "compiler.err.intf.expected.here", "Hier wird eine Schnittstelle erwartet" },
            { "compiler.err.intf.meth.cant.have.body", "Abstrakte Schnittstellenmethoden k\u00F6nnen keinen Body enthalten" },
            { "compiler.err.intf.not.allowed.here", "Schnittstelle hier nicht zul\u00E4ssig" },
            { "compiler.err.invalid.A.key", "Schl\u00FCssel in Annotationsprozessoroption \"{0}\" ist keine durch Punkt getrennte ID-Sequenz" },
            { "compiler.err.invalid.accessor.method.in.record", "Ung\u00FCltige Accessor-Methode in Datensatz {0}\n({1})" },
            { "compiler.err.invalid.annotation.member.type", "Ung\u00FCltiger Typ f\u00FCr Annotationsschnittstellenelement" },
            { "compiler.err.invalid.binary.number", "Bin\u00E4rzahlen m\u00FCssen mindestens eine Bin\u00E4rziffer enthalten" },
            { "compiler.err.invalid.canonical.constructor.in.record", "Ung\u00FCltiger Konstruktor vom Typ {0} in Datensatz {1}\n({2})" },
            { "compiler.err.invalid.case.label.combination", "ung\u00FCltige Case-Label-Kombination" },
            { "compiler.err.invalid.flag", "Ung\u00FCltiges Kennzeichen: {0}" },
            { "compiler.err.invalid.hex.number", "Hexadezimalzahlen m\u00FCssen mindestens eine Hexadezimalziffer enthalten" },
            { "compiler.err.invalid.lambda.parameter.declaration", "Ung\u00FCltige Lambda-Parameterdeklaration\n({0})" },
            { "compiler.err.invalid.meth.decl.ret.type.req", "Ung\u00FCltige Methodendeklaration. R\u00FCckgabetyp erforderlich" },
            { "compiler.err.invalid.module.directive", "Moduldirektiven-Schl\u00FCsselwort oder \"}\" erwartet" },
            { "compiler.err.invalid.module.specifier", "Modulbezeichner nicht zul\u00E4ssig: {0}" },
            { "compiler.err.invalid.mref", "Ung\u00FCltige {0}-Referenz\n{1}" },
            { "compiler.err.invalid.path", "Ung\u00FCltiger Dateiname: {0}" },
            { "compiler.err.invalid.permits.clause", "Ung\u00FCltige PERMITS-Klausel\n({0})" },
            { "compiler.err.invalid.profile", "Ung\u00FCltiges Profil: {0}" },
            { "compiler.err.invalid.repeatable.annotation", "Doppelte Annotation: {0} ist mit einer ung\u00FCltigen @Repeatable-Annotation versehen" },
            { "compiler.err.invalid.repeatable.annotation.elem.nondefault", "\u00DCbergeordnete Annotationsschnittstelle ({0}) enth\u00E4lt keinen Standardwert f\u00FCr Element {1}" },
            { "compiler.err.invalid.repeatable.annotation.incompatible.target", "\u00DCbergeordnete Annotationsschnittstelle ({0}) gilt f\u00FCr mehr Ziele als die wiederholbare Annotationsschnittstelle ({1})" },
            { "compiler.err.invalid.repeatable.annotation.invalid.value", "{0} ist keine g\u00FCltige @Repeatable-Annotation. Ung\u00FCltiges Wertelement" },
            { "compiler.err.invalid.repeatable.annotation.multiple.values", "{0} ist keine g\u00FCltige @Repeatable-Annotation. {1} Elementmethoden namens \"value\" deklariert" },
            { "compiler.err.invalid.repeatable.annotation.no.value", "{0} ist keine g\u00FCltige @Repeatable-Annotation. Keine Wertelementmethode deklariert" },
            { "compiler.err.invalid.repeatable.annotation.not.applicable", "Container {0} ist nicht anwendbar f\u00FCr Element {1}" },
            { "compiler.err.invalid.repeatable.annotation.not.applicable.in.context", "Container {0} ist in diesem Typkontext nicht anwendbar" },
            { "compiler.err.invalid.repeatable.annotation.not.documented", "Wiederholbare Annotationsschnittstelle ({1}) ist @Documented, die \u00FCbergeordnete Annotationsschnittstelle ({0}) aber nicht" },
            { "compiler.err.invalid.repeatable.annotation.not.inherited", "Wiederholbare Annotationsschnittstelle ({1}) ist @Inherited, die \u00FCbergeordnete Annotationsschnittstelle ({0}) aber nicht" },
            { "compiler.err.invalid.repeatable.annotation.repeated.and.container.present", "Container {0} darf nicht gleichzeitig mit dem darin enthaltenen Element vorhanden sein" },
            { "compiler.err.invalid.repeatable.annotation.retention", "Aufbewahrung der \u00FCbergeordneten Annotationsschnittstelle ({0}) ist k\u00FCrzer als die Aufbewahrung der wiederholbaren Annotationsschnittstelle ({2})" },
            { "compiler.err.invalid.repeatable.annotation.value.return", "\u00DCbergeordnete Annotationsschnittstelle ({0}) muss ein Element namens \"value\" mit dem Typ {2} deklarieren" },
            { "compiler.err.invalid.source", "Ung\u00FCltiges Quellrelease: {0}" },
            { "compiler.err.invalid.supertype.record", "Klassen k\u00F6nnen {0} nicht direkt erweitern" },
            { "compiler.err.invalid.target", "Ung\u00FCltiges Zielrelease: {0}" },
            { "compiler.err.invalid.yield", "Ung\u00FCltige Verwendung der eingeschr\u00E4nkten ID \"yield\"\n(um eine Methode namens \"yield\" aufzurufen, qualifizieren Sie den yield-Aufruf mit einem Empf\u00E4nger oder Typnamen)" },
            { "compiler.err.io.exception", "Fehler beim Lesen der Quelldatei: {0}" },
            { "compiler.err.is.preview", "{0} ist eine Vorschau-API, die standardm\u00E4\u00DFig deaktiviert ist.\n(Verwenden Sie --enable-preview, um Vorschau-APIs zu aktivieren)" },
            { "compiler.err.label.already.in.use", "Label {0} wird bereits verwendet" },
            { "compiler.err.lambda.body.neither.value.nor.void.compatible", "Lambda-Body ist weder mit Wert noch mit \"void \"kompatibel" },
            { "compiler.err.limit.code", "Code zu gro\u00DF" },
            { "compiler.err.limit.code.too.large.for.try.stmt", "Code f\u00FCr try-Anweisung zu gro\u00DF" },
            { "compiler.err.limit.dimensions", "Arraytyp hat zu viele Dimensionen" },
            { "compiler.err.limit.locals", "Zu viele lokale Variablen" },
            { "compiler.err.limit.parameters", "Zu viele Parameter" },
            { "compiler.err.limit.pool", "Zu viele Konstanten" },
            { "compiler.err.limit.pool.in.class", "Zu viele Konstanten in Klasse {0}" },
            { "compiler.err.limit.stack", "Code erfordert zu viel Stack" },
            { "compiler.err.limit.string", "Konstantenzeichenfolge zu lang" },
            { "compiler.err.limit.string.overflow", "UTF8-Darstellung f\u00FCr Zeichenfolge \"{0}...\" ist zu lang f\u00FCr den Konstantenpool" },
            { "compiler.err.local.classes.cant.extend.sealed", "Klassen vom Typ \"{0}\" d\u00FCrfen keine verschl\u00FCsselten Klassen erweitern" },
            { "compiler.err.local.enum", "Enum-Klassen d\u00FCrfen nicht lokal sein" },
            { "compiler.err.locn.bad.module-info", "Problem beim Lesen von module-info.class in {0}" },
            { "compiler.err.locn.cant.get.module.name.for.jar", "Modulname f\u00FCr {0} kann nicht bestimmt werden" },
            { "compiler.err.locn.cant.read.directory", "Verzeichnis {0} kann nicht gelesen werden" },
            { "compiler.err.locn.cant.read.file", "Datei {0} kann nicht gelesen werden" },
            { "compiler.err.locn.invalid.arg.for.xpatch", "Ung\u00FCltiges Argument f\u00FCr --patch-module-Option: {0}" },
            { "compiler.err.locn.module-info.not.allowed.on.patch.path", "module-info.class nicht in Patchpfad zul\u00E4ssig: {0}" },
            { "compiler.err.malformed.fp.lit", "Nicht wohlgeformtes Gleitkommaliteral" },
            { "compiler.err.match.binding.exists", "Unzul\u00E4ssiger Versuch, ein vorhandenes \u00DCbereinstimmungs-Binding neu zu definieren" },
            { "compiler.err.method.does.not.override.superclass", "Methode \u00FCberschreibt oder implementiert keine Methode aus einem Supertyp" },
            { "compiler.err.missing.meth.body.or.decl.abstract", "Methodenbody fehlt oder als abstrakt deklarieren" },
            { "compiler.err.missing.ret.stmt", "R\u00FCckgabeanweisung fehlt" },
            { "compiler.err.mod.not.allowed.here", "Modifikator {0} hier nicht zul\u00E4ssig" },
            { "compiler.err.modifier.not.allowed.here", "Modifikator {0} hier nicht zul\u00E4ssig" },
            { "compiler.err.module.decl.sb.in.module-info.java", "Moduldeklarationen m\u00FCssen in einer Datei namens module-info.java vorhanden sein" },
            { "compiler.err.module.name.mismatch", "Modulname {0} stimmt nicht mit dem erwarteten Namen {1} \u00FCberein" },
            { "compiler.err.module.non.zero.opens", "Bei ge\u00F6ffnetem Modul {0} ist opens_count ungleich Null" },
            { "compiler.err.module.not.found", "Modul nicht gefunden: {0}" },
            { "compiler.err.module.not.found.in.module.source.path", "Modul {0} nicht in Modulquellpfad gefunden" },
            { "compiler.err.module.not.found.on.module.source.path", "Modul nicht in Modulquellpfad gefunden" },
            { "compiler.err.modulesourcepath.must.be.specified.with.dash.m.option", "Modulquellpfad muss angegeben werden, wenn die Option -m verwendet wird" },
            { "compiler.err.multi-module.outdir.cannot.be.exploded.module", "Im Modus f\u00FCr mehrere Module kann das Ausgabeverzeichnis kein entpacktes Modul sein: {0}" },
            { "compiler.err.multicatch.parameter.may.not.be.assigned", "multi-catch-Parameter {0} darf nicht zugewiesen werden" },
            { "compiler.err.multicatch.types.must.be.disjoint", "Alternativen in einer multi-catch-Anweisung d\u00FCrfen nicht durch Unterklassen verkn\u00FCpft sein\nAlternative {0} ist eine Unterklasse der Alternative {1}" },
            { "compiler.err.multiple.values.for.module.source.path", "--module-source-path mehrmals mit Musterargument angegeben" },
            { "compiler.err.name.clash.same.erasure", "Namenskonflikt: {0} und {1} haben dieselbe Erasure" },
            { "compiler.err.name.clash.same.erasure.no.hide", "Namenskonflikt: {0} in {1} und {2} in {3} haben dieselbe Erasure, aber keine blendet die andere aus" },
            { "compiler.err.name.clash.same.erasure.no.override", "Namenskonflikt: {0}({1}) in {2} und {3}({4}) in {5} haben dieselbe Erasure, aber keine setzt die andere au\u00DFer Kraft" },
            { "compiler.err.name.clash.same.erasure.no.override.1", "Namenskonflikt: {0} {1} hat zwei Methoden mit derselben Erasure, aber keine setzt die andere au\u00DFer Kraft\nErste Methode: {2}({3}) in {4}\nZweite Methode: {5}({6}) in {7}" },
            { "compiler.err.name.reserved.for.internal.use", "{0} ist f\u00FCr den internen Gebrauch reserviert" },
            { "compiler.err.native.meth.cant.have.body", "Native Methoden k\u00F6nnen keinen Body enthalten" },
            { "compiler.err.new.not.allowed.in.annotation", "\"new\" in einer Annotation nicht zul\u00E4ssig" },
            { "compiler.err.no.annotation.member", "Kein Annotationsmitglied {0} in {1}" },
            { "compiler.err.no.annotations.on.dot.class", "Keine Annotationen im Typ eines Klassenliterals zul\u00E4ssig" },
            { "compiler.err.no.encl.instance.of.type.in.scope", "Keine einschlie\u00DFende Instanz vom Typ {0} im Geltungsbereich" },
            { "compiler.err.no.intf.expected.here", "Hier wird keine Schnittstelle erwartet" },
            { "compiler.err.no.java.lang", "Package java.lang kann in Plattformklassen nicht gefunden werden" },
            { "compiler.err.no.match.entry", "{0} hat keine \u00DCbereinstimmung im Eintrag in {1}. {2} erforderlich" },
            { "compiler.err.no.opens.unless.strong", "\"opens\" nur in starken Modulen zul\u00E4ssig" },
            { "compiler.err.no.output.dir", "Kein Klassenausgabeverzeichnis angegeben" },
            { "compiler.err.no.pkg.in.module-info.java", "Packagedeklarationen in Datei module-info.java nicht zul\u00E4ssig" },
            { "compiler.err.no.source.files", "Keine Quelldateien" },
            { "compiler.err.no.source.files.classes", "Keine Quelldateien oder Klassennamen" },
            { "compiler.err.no.superclass", "{0} weist keine Superklasse auf." },
            { "compiler.err.no.switch.expression", "\"yield\" au\u00DFerhalb von Switch-Ausdruck" },
            { "compiler.err.no.switch.expression.qualify", "\"yield\" au\u00DFerhalb von Switch-Ausdruck\n(um eine Methode namens \"yield\" aufzurufen, qualifizieren Sie den yield-Aufruf mit einem Empf\u00E4nger oder Typnamen)" },
            { "compiler.err.no.value.for.option", "Kein Wert f\u00FCr {0}-Option" },
            { "compiler.err.no.zipfs.for.archive", "Kein Dateisystemprovider zur Verarbeitung dieser Datei verf\u00FCgbar: {0}" },
            { "compiler.err.non-static.cant.be.ref", "{0} {1} ist nicht statisch und kann nicht aus einem statischen Kontext referenziert werden" },
            { "compiler.err.non.sealed.or.sealed.expected", "Modifikator \"sealed\" oder \"non-sealed\" erwartet" },
            { "compiler.err.non.sealed.sealed.or.final.expected", "Modifikator \"sealed\", \"non-sealed\" oder \"final\" erwartet" },
            { "compiler.err.non.sealed.with.no.sealed.supertype", "Modifikator \"non-sealed\" ist hier nicht zul\u00E4ssig\n(Klasse {0} hat keine verschl\u00FCsselten Supertypen)" },
            { "compiler.err.not.a.processor.type", "Kein Prozessortyp: {0}" },
            { "compiler.err.not.annotation.type", "{0} ist keine Annotationsschnittstelle" },
            { "compiler.err.not.def.access.class.intf.cant.access", "{1}.{0} ist in einer nicht zug\u00E4nglichen Klasse oder Schnittstelle definiert" },
            { "compiler.err.not.def.access.class.intf.cant.access.reason", "{1}.{0} in Package {2} ist nicht zug\u00E4nglich\n({3})" },
            { "compiler.err.not.def.access.package.cant.access", "{0} ist nicht sichtbar\n({2})" },
            { "compiler.err.not.def.public", "{0} ist nicht \u00F6ffentlich in {1}" },
            { "compiler.err.not.def.public.cant.access", "{0} ist nicht \u00F6ffentlich in {1}. Zugriff von externem Package nicht m\u00F6glich" },
            { "compiler.err.not.encl.class", "Keine einschlie\u00DFende Klasse: {0}" },
            { "compiler.err.not.exhaustive", "Der Switch-Ausdruck deckt nicht alle m\u00F6glichen Eingabewerte ab" },
            { "compiler.err.not.exhaustive.statement", "Die Switch-Anweisung deckt nicht alle m\u00F6glichen Eingabewerte ab" },
            { "compiler.err.not.in.module.on.module.source.path", "Nicht in einem Modul im Modulquellpfad" },
            { "compiler.err.not.in.profile", "{0} ist in Profil \"{1}\" nicht verf\u00FCgbar" },
            { "compiler.err.not.loop.label", "Kein Schleifenlabel: {0}" },
            { "compiler.err.not.stmt", "Keine Anweisung" },
            { "compiler.err.not.within.bounds", "Typargument {0} liegt nicht innerhalb des g\u00FCltigen Bereichs von Typvariable {1}" },
            { "compiler.err.operator.cant.be.applied", "Ung\u00FCltiger Operandentyp {1} f\u00FCr un\u00E4ren Operator \"{0}\"" },
            { "compiler.err.operator.cant.be.applied.1", "Ung\u00FCltige Operandentypen f\u00FCr un\u00E4ren Operator \"{0}\"\nErster Typ: {1}\nZweiter Typ: {2}" },
            { "compiler.err.option.not.allowed.with.target", "Option {0} mit Ziel {1} nicht zul\u00E4ssig" },
            { "compiler.err.option.removed.source", "Quelloption {0} wird nicht mehr unterst\u00FCtzt. Verwenden Sie {1} oder h\u00F6her." },
            { "compiler.err.option.removed.target", "Zieloption {0} wird nicht mehr unterst\u00FCtzt. Verwenden Sie {1} oder h\u00F6her." },
            { "compiler.err.option.too.many", "Option {0} kann nur einmal angegeben werden" },
            { "compiler.err.orphaned", "{0} verwaist" },
            { "compiler.err.output.dir.must.be.specified.with.dash.m.option", "Klassenausgabeverzeichnis muss angegeben werden, wenn die Option -m verwendet wird" },
            { "compiler.err.override.incompatible.ret", "{0}\nR\u00FCckgabetyp {1} ist nicht mit {2} kompatibel" },
            { "compiler.err.override.meth", "{0}\nAu\u00DFer Kraft gesetzte Methode ist {1}" },
            { "compiler.err.override.meth.doesnt.throw", "{0}\nAu\u00DFer Kraft gesetzte Methode l\u00F6st nicht {1} aus" },
            { "compiler.err.override.static", "{0}\nAu\u00DFer Kraft setzende Methode ist statisch" },
            { "compiler.err.override.weaker.access", "{0}\nVersuch, niedrigere Zugriffsberechtigungen zuzuweisen. War {1}" },
            { "compiler.err.package.clash.from.requires", "Modul {0} liest Package {1} sowohl aus {2} als auch aus {3}" },
            { "compiler.err.package.clash.from.requires.in.unnamed", "Das unbenannte Modul liest Package {0} sowohl aus {1} als auch aus {2}" },
            { "compiler.err.package.empty.or.not.found", "Package ist leer oder nicht vorhanden: {0}" },
            { "compiler.err.package.in.other.module", "Package ist in einem anderen Modul vorhanden: {0}" },
            { "compiler.err.package.not.visible", "Package {0} ist nicht sichtbar\n({1})" },
            { "compiler.err.pattern.dominated", "Dieses CASE-Label wird von einem vorherigen CASE-Label dominiert" },
            { "compiler.err.pattern.expected", "Typmuster erwartet" },
            { "compiler.err.pattern.or.enum.req", "Muster oder Enum-Konstante erforderlich" },
            { "compiler.err.pattern.type.cannot.infer", "Mustertyp kann nicht abgeleitet werden" },
            { "compiler.err.pkg.annotations.sb.in.package-info.java", "Packageannotationen m\u00FCssen in der Datei package-info.java vorhanden sein" },
            { "compiler.err.pkg.clashes.with.class.of.same.name", "Es besteht ein Konflikt zwischen dem Package {0} und einer gleichnamigen Klasse" },
            { "compiler.err.plugin.not.found", "Plug-in nicht gefunden: {0}" },
            { "compiler.err.premature.eof", "Dateiende beim Parsen erreicht" },
            { "compiler.err.preview.feature.disabled", "{0} ist ein Vorschaufeature, das standardm\u00E4\u00DFig deaktiviert ist.\n(Verwenden Sie --enable-preview, um {0} zu aktivieren)" },
            { "compiler.err.preview.feature.disabled.classfile", "Klassendatei f\u00FCr {0} verwendet Vorschaufeatures von Java SE {1}.\n(Verwenden Sie --enable-preview, um das Laden von Klassendateien mit Vorschaufeatures zu erm\u00F6glichen)" },
            { "compiler.err.preview.feature.disabled.plural", "{0} sind ein Vorschaufeature, das standardm\u00E4\u00DFig deaktiviert ist.\n(Verwenden Sie --enable-preview, um {0} zu aktivieren)" },
            { "compiler.err.preview.not.latest", "Ung\u00FCltiges Quellrelease {0} mit --enable-preview\n(Vorschausprachfeatures werden nur f\u00FCr Release {1} unterst\u00FCtzt)" },
            { "compiler.err.preview.without.source.or.release", "--enable-preview muss mit -source oder --release verwendet werden" },
            { "compiler.err.prob.found.req", "Inkompatible Typen: {0}" },
            { "compiler.err.proc.bad.config.file", "Ung\u00FCltige Servicekonfigurationsdatei, oder Ausnahme beim Erstellen des Prozessorobjekts ausgel\u00F6st: {0}" },
            { "compiler.err.proc.cant.access", "Kein Zugriff auf {0}\n{1}\nDetails finden Sie im folgenden Stacktrace.\n{2}" },
            { "compiler.err.proc.cant.access.1", "Kein Zugriff auf {0}\n{1}" },
            { "compiler.err.proc.cant.create.loader", "Class Loader konnte nicht f\u00FCr Annotationsprozessoren erstellt werden: {0}" },
            { "compiler.err.proc.cant.find.class", "Klassendatei f\u00FCr \"{0}\" konnte nicht gefunden werden." },
            { "compiler.err.proc.cant.load.class", "Prozessorklassendatei konnte nicht geladen werden. Grund: \"{0}\"." },
            { "compiler.err.proc.messager", "{0}" },
            { "compiler.err.proc.no.explicit.annotation.processing.requested", "Klassennamen \"{0}\" werden nur akzeptiert, wenn die Annotationsverarbeitung explizit angefordert wird" },
            { "compiler.err.proc.no.service", "ServiceLoader konnte nicht verwendet werden und ist f\u00FCr Annotationsverarbeitung erforderlich." },
            { "compiler.err.proc.processor.bad.option.name", "Ung\u00FCltiger Optionsname \"{0}\" von Prozessor \"{1}\" angegeben" },
            { "compiler.err.proc.processor.cant.instantiate", "Instanz von Prozessor \"{0}\" konnte nicht instanziiert werden" },
            { "compiler.err.proc.processor.not.found", "Annotationsprozessor \"{0}\" nicht gefunden" },
            { "compiler.err.proc.processor.wrong.type", "Annotationsprozessor \"{0}\" implementiert nicht javax.annotation.processing.Processor" },
            { "compiler.err.proc.service.problem", "Fehler beim Erstellen eines Service-Loaders zum Laden von Prozessoren." },
            { "compiler.err.processor.missing.from.string.template.expression", "Prozessor fehlt in Zeichenfolgenvorlagen-Ausdruck" },
            { "compiler.err.processor.type.cannot.be.a.raw.type", "Prozessortyp kann kein Raw-Typ sein: {0}" },
            { "compiler.err.processorpath.no.processormodulepath", "Unzul\u00E4ssige Kombination aus -processorpath und --processor-module-path" },
            { "compiler.err.profile.bootclasspath.conflict", "Optionen \"profile\" und \"bootclasspath\" k\u00F6nnen nicht zusammen verwendet werden" },
            { "compiler.err.qualified.new.of.static.class", "\"new\" von statischer Klasse qualifiziert" },
            { "compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class", "receiver-Parameter nicht f\u00FCr Konstruktor der obersten Klasse anwendbar" },
            { "compiler.err.record.cannot.declare.instance.fields", "Felddeklaration muss statisch sein\n(ersetzen Sie unter Umst\u00E4nden das Feld durch eine Datensatzkomponente)" },
            { "compiler.err.record.cant.declare.field.modifiers", "Datensatzkomponenten k\u00F6nnen keine Modifikatoren aufweisen" },
            { "compiler.err.record.component.and.old.array.syntax", "Legacy-Arraynotation f\u00FCr Datensatzkomponenten nicht zul\u00E4ssig" },
            { "compiler.err.record.patterns.annotations.not.allowed", "Annotationen in Datensatzmustern nicht zul\u00E4ssig" },
            { "compiler.err.recursive.ctor.invocation", "Rekursiver Konstruktoraufruf" },
            { "compiler.err.ref.ambiguous", "Referenz zu {0} ist mehrdeutig\nSowohl {1} {2} in {3} als auch {4} {5} in {6} stimmen \u00FCberein" },
            { "compiler.err.release.bootclasspath.conflict", "Option {0} kann nicht zusammen mit --release verwendet werden" },
            { "compiler.err.repeated.annotation.target", "Wiederholtes Annotationsziel" },
            { "compiler.err.repeated.interface", "Wiederholte Schnittstelle" },
            { "compiler.err.repeated.modifier", "Wiederholter Modifikator" },
            { "compiler.err.repeated.provides.for.service", "Mehrere \"provides\" f\u00FCr Service {0}" },
            { "compiler.err.repeated.value.for.module.source.path", "--module-source-path mehrmals f\u00FCr Modul {0} angegeben" },
            { "compiler.err.repeated.value.for.patch.module", "--patch-module mehrmals f\u00FCr Modul {0} angegeben" },
            { "compiler.err.report.access", "{0} hat {1}-Zugriff in {2}" },
            { "compiler.err.req.arg", "{0} erfordert ein Argument" },
            { "compiler.err.restricted.type.not.allowed", "\"{0}\" ist hier nicht zul\u00E4ssig\nAb Release {1} ist \"{0}\" ein eingeschr\u00E4nkter Typname, der nicht f\u00FCr Typdeklarationen verwendet werden kann" },
            { "compiler.err.restricted.type.not.allowed.array", "\"{0}\" ist nicht als Elementtyp eines Arrays zul\u00E4ssig" },
            { "compiler.err.restricted.type.not.allowed.compound", "\"{0}\" ist nicht in einer zusammengesetzten Deklaration zul\u00E4ssig" },
            { "compiler.err.restricted.type.not.allowed.here", "\"{0}\" ist hier nicht zul\u00E4ssig" },
            { "compiler.err.ret.outside.meth", "R\u00FCckgabe au\u00DFerhalb von Methode" },
            { "compiler.err.return.outside.switch.expression", "Versuch, aus einem Switch-Ausdruck zur\u00FCckzukehren" },
            { "compiler.err.rule.completes.normally", "Switch-Regel wird ohne Angabe eines Wertes abgeschlossen\n(Switch-Regeln in Switch-Ausdr\u00FCcken m\u00FCssen einen Wert oder Throw angeben)" },
            { "compiler.err.same.binary.name", "Klassen {0} und {1} haben denselben bin\u00E4ren Namen" },
            { "compiler.err.sealed.class.must.have.subclasses", "Verschl\u00FCsselte Klasse muss Unterklassen aufweisen" },
            { "compiler.err.sealed.or.non.sealed.local.classes.not.allowed", "Lokale Klassen mit \"sealed\" oder \"non-sealed\" nicht zul\u00E4ssig" },
            { "compiler.err.service.definition.is.enum", "Die Servicedefinition ist eine Enumeration: {0}" },
            { "compiler.err.service.implementation.doesnt.have.a.no.args.constructor", "Die Serviceimplementierung hat keinen Standardkonstruktor: {0}" },
            { "compiler.err.service.implementation.is.abstract", "Die Serviceimplementierung ist eine abstrakte Klasse: {0}" },
            { "compiler.err.service.implementation.is.inner", "Die Serviceimplementierung ist eine innere Klasse: {0}" },
            { "compiler.err.service.implementation.must.be.subtype.of.service.interface", "Der Serviceimplementierungstyp muss ein Subtyp des Serviceschnittstellentyps sein oder eine \u00F6ffentliche statische no-args-Methode namens \"provider\" aufweisen, die die Serviceimplementierung zur\u00FCckgibt" },
            { "compiler.err.service.implementation.no.args.constructor.not.public", "Der \"no arguments\"-Konstruktor der Serviceimplementierung ist nicht \u00F6ffentlich: {0}" },
            { "compiler.err.service.implementation.not.in.right.module", "Serviceimplementierung muss in demselben Modul wie die provides-Direktive definiert werden" },
            { "compiler.err.service.implementation.provider.return.must.be.subtype.of.service.interface", "Der R\u00FCckgabetyp der \"provider\"-Methode muss ein Subtyp des Serviceschnittstellentyps sein" },
            { "compiler.err.signature.doesnt.match.intf", "Signatur stimmt nicht mit {0} \u00FCberein. Inkompatible Schnittstellen" },
            { "compiler.err.signature.doesnt.match.supertype", "Signatur stimmt nicht mit {0} \u00FCberein. Inkompatibler Supertyp" },
            { "compiler.err.source.cant.overwrite.input.file", "Fehler beim Schreiben von Quelle. Eingabedatei {0} kann nicht \u00FCberschrieben werden" },
            { "compiler.err.sourcepath.modulesourcepath.conflict", "--source-path und --module-source-path k\u00F6nnen nicht beide angegeben werden" },
            { "compiler.err.stack.sim.error", "Interner Fehler: Stacksimulationsfehler in {0}" },
            { "compiler.err.static.declaration.not.allowed.in.inner.classes", "Statische Deklarationen in inneren Klassen nicht zul\u00E4ssig" },
            { "compiler.err.static.imp.only.classes.and.interfaces", "Statischer Import nur aus Klassen und Schnittstellen" },
            { "compiler.err.static.methods.cannot.be.annotated.with.override", "Statische Methoden k\u00F6nnen nicht mit @Override-Annotation versehen werden" },
            { "compiler.err.string.const.req", "Konstanten-Zeichenfolgenausdruck erforderlich" },
            { "compiler.err.string.template.is.not.well.formed", "Zeichenfolgenvorlage ist nicht wohlgeformt" },
            { "compiler.err.switch.case.unexpected.statement", "Unerwartete Anweisung in Case. Ausdruck, Block oder throw-Anweisung erwartet" },
            { "compiler.err.switch.expression.completes.normally", "Switch-Ausdruck wird ohne Angabe eines Wertes abgeschlossen\n(Switch-Ausdr\u00FCcke m\u00FCssen einen Wert angeben oder einen Throw f\u00FCr alle m\u00F6glichen Eingabewerte ausgeben)" },
            { "compiler.err.switch.expression.empty", "Switch-Ausdruck enth\u00E4lt keine CASE-Klauseln" },
            { "compiler.err.switch.expression.no.result.expressions", "Switch-Ausdruck enth\u00E4lt keine Ergebnisausdr\u00FCcke" },
            { "compiler.err.switch.mixing.case.types", "Unterschiedliche Case-Typen im Switch verwendet" },
            { "compiler.err.text.block.template.is.not.well.formed", "Textblockvorlage ist nicht wohlgeformt" },
            { "compiler.err.this.as.identifier", "Ab Release 8 ist \"this\" nur als Parametername f\u00FCr den Empf\u00E4ngertyp zul\u00E4ssig.\nDas muss der erste Parameter sein und darf kein Lambda-Parameter sein" },
            { "compiler.err.throws.not.allowed.in.intf.annotation", "Throws-Klausel in @interface-Mitgliedern nicht zul\u00E4ssig" },
            { "compiler.err.too.many.modules", "Zu viele Moduldeklarationen gefunden" },
            { "compiler.err.too.many.patched.modules", "Zu viele gepatchte Module ({0}). Verwenden Sie --module-source-path" },
            { "compiler.err.try.resource.may.not.be.assigned", "auto-closeable-Ressource {0} darf nicht zugewiesen werden" },
            { "compiler.err.try.with.resources.expr.effectively.final.var", "Variable {0}, die als try-with-resources-Ressource verwendet wurde, ist weder final noch effektiv final" },
            { "compiler.err.try.with.resources.expr.needs.var", "Die try-with-resources-Ressource muss eine Variablendeklaration oder ein Ausdruck mit einer Referenz zu einer finalen oder effektiv finalen Variable sein" },
            { "compiler.err.try.without.catch.finally.or.resource.decls", "\"try\" ohne \"catch\", \"finally\" oder Ressourcendeklarationen" },
            { "compiler.err.two.class.loaders.1", "javac ist auf mehrere Class Loader aufgeteilt: Pr\u00FCfen Sie die Konfiguration" },
            { "compiler.err.two.class.loaders.2", "javac ist auf mehrere Class Loader aufgeteilt:\nEine Klasse stammt aus Datei {0},\nw\u00E4hrend javac aus {1} stammt" },
            { "compiler.err.type.doesnt.take.params", "Typ {0} akzeptiert keine Parameter" },
            { "compiler.err.type.found.req", "Unerwarteter Typ\nErforderlich: {1}\nErmittelt:    {0}" },
            { "compiler.err.type.var.cant.be.deref", "Auswahl aus Typvariable nicht m\u00F6glich" },
            { "compiler.err.type.var.may.not.be.followed.by.other.bounds", "Auf eine Typvariable d\u00FCrfen keine anderen Begrenzungen folgen" },
            { "compiler.err.type.var.more.than.once", "Typvariable {0} tritt mehrmals im Ergebnistyp von {1} auf. Sie muss instanziiert werden" },
            { "compiler.err.type.var.more.than.once.in.result", "Typvariable {0} tritt mehrmals im Typ von {1} auf. Sie muss instanziiert werden" },
            { "compiler.err.types.incompatible", "Die Typen {0} und {1} sind inkompatibel.\n{2}" },
            { "compiler.err.unclosed.char.lit", "Nicht geschlossenes Zeichenliteral" },
            { "compiler.err.unclosed.comment", "Nicht geschlossener Kommentar" },
            { "compiler.err.unclosed.str.lit", "Nicht geschlossenes Zeichenfolgenliteral" },
            { "compiler.err.unclosed.text.block", "Nicht geschlossener Textblock" },
            { "compiler.err.unconditional.pattern.and.default", "Switch umfasst sowohl ein nicht bedingtes Muster als auch ein Standardlabel" },
            { "compiler.err.undef.label", "Nicht definiertes Label: {0}" },
            { "compiler.err.underscore.as.identifier", "Ab Release 9 ist \"_\" ein Schl\u00FCsselwort und kann nicht als ID verwendet werden" },
            { "compiler.err.unexpected.lambda", "Hier wird kein Lambda-Ausdruck erwartet" },
            { "compiler.err.unexpected.mref", "Hier wird keine Methodenreferenz erwartet" },
            { "compiler.err.unexpected.type", "Unerwarteter Typ\nErforderlich: {0}\nErmittelt:    {1}" },
            { "compiler.err.unmatched.quote", "Alleinstehendes Anf\u00FChrungszeichen in Umgebungsvariable {0}" },
            { "compiler.err.unnamed.class.does.not.have.main.method", "Unbenannte Klasse weist keine Hauptmethode im Format \"void main()\" oder \"void main(String[] args)\" auf" },
            { "compiler.err.unnamed.class.should.not.have.package.declaration", "Unbenannte Klasse darf keine Packagedeklaration aufweisen" },
            { "compiler.err.unnamed.pkg.not.allowed.named.modules", "Unbenanntes Package ist in benannten Modulen nicht zul\u00E4ssig" },
            { "compiler.err.unreachable.stmt", "Nicht erreichbare Anweisung" },
            { "compiler.err.unreported.exception.default.constructor", "Nicht gemeldete Ausnahme {0} in Standardkonstruktor" },
            { "compiler.err.unreported.exception.implicit.close", "Nicht gemeldete Ausnahme {0}. Muss abgefangen oder deklariert werden, um ausgel\u00F6st zu werden\nAusnahme bei implizitem Aufruf von close() f\u00FCr Ressourcenvariable \"{1}\" ausgel\u00F6st" },
            { "compiler.err.unreported.exception.need.to.catch.or.throw", "Nicht gemeldete Ausnahme {0}. Muss abgefangen oder deklariert werden, um ausgel\u00F6st zu werden" },
            { "compiler.err.unsupported.encoding", "Nicht unterst\u00FCtzte Codierung: {0}" },
            { "compiler.err.unsupported.release.version", "Releaseversion {0} nicht unterst\u00FCtzt" },
            { "compiler.err.use.of.underscore.not.allowed", "Ab Release 21 ist nur das Unterstrichschl\u00FCsselwort \"_\" zul\u00E4ssig, um\nunbenannte Muster, lokale Variablen, Ausnahmeparameter oder Lambda-Parameter zu deklarieren" },
            { "compiler.err.use.of.underscore.not.allowed.with.brackets", "Auf das Unterstrichschl\u00FCsselwort \"_\" d\u00FCrfen keine Klammern folgen" },
            { "compiler.err.var.might.already.be.assigned", "Variable {0} wurde m\u00F6glicherweise bereits zugewiesen" },
            { "compiler.err.var.might.be.assigned.in.loop", "Variable {0} wurde m\u00F6glicherweise in Schleife zugewiesen" },
            { "compiler.err.var.might.not.have.been.initialized", "Variable {0} wurde m\u00F6glicherweise nicht initialisiert" },
            { "compiler.err.var.not.initialized.in.default.constructor", "Variable {0} nicht im Standardkonstruktor initialisiert" },
            { "compiler.err.varargs.and.old.array.syntax", "Legacy-Arraynotation f\u00FCr Parameter mit variabler Argumentanzahl nicht zul\u00E4ssig" },
            { "compiler.err.varargs.and.receiver", "varargs-Notation f\u00FCr receiver-Parameter nicht zul\u00E4ssig" },
            { "compiler.err.varargs.invalid.trustme.anno", "Ung\u00FCltige {0}-Annotation. {1}" },
            { "compiler.err.varargs.must.be.last", "varargs-Parameter muss der letzte Parameter sein" },
            { "compiler.err.variable.not.allowed", "Variablendeklaration hier nicht zul\u00E4ssig" },
            { "compiler.err.void.not.allowed.here", "\"void\"-Typ hier nicht zul\u00E4ssig" },
            { "compiler.err.warnings.and.werror", "Warnungen gefunden und -Werror angegeben" },
            { "compiler.err.wrong.number.type.args", "Falsche Anzahl Typargumente. {0} erforderlich" },
            { "compiler.err.wrong.receiver", "Falscher receiver-Parametername" },
            { "compiler.misc.accessor.method.cant.throw.exception", "Throws-Klausel f\u00FCr Accessor-Methode nicht zul\u00E4ssig" },
            { "compiler.misc.accessor.method.must.not.be.generic", "Accessor-Methode darf nicht generisch sein" },
            { "compiler.misc.accessor.method.must.not.be.static", "Accessor-Methode darf nicht statisch sein" },
            { "compiler.misc.accessor.return.type.doesnt.match", "R\u00FCckgabetyp von Accessor-Methode {0} muss mit dem Typ der Datensatzkomponente {1} \u00FCbereinstimmen" },
            { "compiler.misc.anachronistic.module.info", "Moduldeklaration in Klassendatei der Version {0}.{1} gefunden" },
            { "compiler.misc.anonymous", "Anonym" },
            { "compiler.misc.anonymous.class", "<anonyme {0}>" },
            { "compiler.misc.applicable.method.found", "#{0} anwendbare Methode gefunden: {1}" },
            { "compiler.misc.applicable.method.found.1", "#{0} anwendbare Methode gefunden: {1}\n({2})" },
            { "compiler.misc.applicable.method.found.2", "#{0} anwendbare Methode gefunden: {1} {2}" },
            { "compiler.misc.applicable.method.found.3", "#{0} anwendbare Methode gefunden: {1} {2}\n({3})" },
            { "compiler.misc.arg.length.mismatch", "Liste der tats\u00E4chlichen Argumente hat eine andere L\u00E4nge als die der formalen Argumente" },
            { "compiler.misc.bad.class.file", "Klassendatei ist ung\u00FCltig f\u00FCr Klasse {0}" },
            { "compiler.misc.bad.class.file.header", "Ung\u00FCltige Klassendatei: {0}\n{1}\nEntfernen Sie die Datei, oder stellen Sie sicher, dass sie im richtigen Unterverzeichnis des Classpath vorhanden ist." },
            { "compiler.misc.bad.class.signature", "Ung\u00FCltige Klassensignatur: {0}" },
            { "compiler.misc.bad.class.truncated.at.offset", "Klassendatei abgeschnitten bei Offset {0}" },
            { "compiler.misc.bad.const.pool.entry", "Ung\u00FCltiger Konstantenpooleintrag in {0}\n{1} bei Index {2} erwartet" },
            { "compiler.misc.bad.const.pool.index", "Ung\u00FCltiger Konstantenpoolindex in {0}\nIndex {1} liegt nicht innerhalb der Poolgr\u00F6\u00DFe {2}." },
            { "compiler.misc.bad.const.pool.tag", "Ung\u00FCltiges Konstantenpooltag: {0}" },
            { "compiler.misc.bad.const.pool.tag.at", "Ung\u00FCltiges Konstantenpooltag {0} bei {1}" },
            { "compiler.misc.bad.constant.range", "Konstantenwert \"{0}\" f\u00FCr {1} liegt au\u00DFerhalb des erwarteten Bereichs f\u00FCr {2}" },
            { "compiler.misc.bad.constant.value", "Ung\u00FCltiger Konstantenwert \"{0}\" f\u00FCr {1}. {2} erwartet" },
            { "compiler.misc.bad.constant.value.type", "Variable des Typs \"{0}\" darf keinen Konstantenwert aufweisen, aber es wurde einer f\u00FCr sie angegeben" },
            { "compiler.misc.bad.enclosing.class", "Ung\u00FCltige einschlie\u00DFende Klasse f\u00FCr {0}: {1}" },
            { "compiler.misc.bad.enclosing.method", "Ung\u00FCltiges einschlie\u00DFendes Methodenattribut f\u00FCr Klasse {0}" },
            { "compiler.misc.bad.instance.method.in.unbound.lookup", "Unerwartete Instanz {0} {1} in ungebundenem Lookup gefunden" },
            { "compiler.misc.bad.intersection.target.for.functional.expr", "Ung\u00FCltiges Schnittmengentypziel f\u00FCr Lambda oder Methodenreferenz\n{0}" },
            { "compiler.misc.bad.module-info.name", "Ung\u00FCltiger Klassenname" },
            { "compiler.misc.bad.requires.flag", "Ung\u00FCltiges requires-Kennzeichen: {0}" },
            { "compiler.misc.bad.runtime.invisible.param.annotations", "Ung\u00FCltiges RuntimeInvisibleParameterAnnotations-Attribut: {0}" },
            { "compiler.misc.bad.signature", "Ung\u00FCltige Signatur: {0}" },
            { "compiler.misc.bad.source.file.header", "Ung\u00FCltige Quelldatei: {0}\n{1}\nEntfernen Sie die Datei, oder stellen Sie sicher, dass sie im richtigen Unterverzeichnis des Quellpfades vorhanden ist." },
            { "compiler.misc.bad.static.method.in.bound.lookup", "Unerwartete statische {0} {1} in gebundenem Lookup gefunden" },
            { "compiler.misc.bad.static.method.in.unbound.lookup", "Unerwartete statische {0} {1} in ungebundenem Lookup gefunden" },
            { "compiler.misc.bad.type.annotation.value", "Ung\u00FCltiger Typ f\u00FCr Annotationszielwert: {0}" },
            { "compiler.misc.bad.utf8.byte.sequence.at", "Ung\u00FCltige UTF-8-Bytesequenz bei {0}" },
            { "compiler.misc.bound", "gebunden" },
            { "compiler.misc.canonical", "Kanonisch" },
            { "compiler.misc.canonical.cant.have.return.statement", "Kompakter Konstruktor darf keine return-Anweisungen verwenden" },
            { "compiler.misc.canonical.must.not.contain.explicit.constructor.invocation", "Kanonischer Konstruktor darf keinen expliziten Konstruktoraufruf enthalten" },
            { "compiler.misc.canonical.must.not.declare.type.variables", "Kanonischer Konstruktor darf keine Typvariablen deklarieren" },
            { "compiler.misc.canonical.must.not.have.stronger.access", "Versuch, h\u00F6here Zugriffsberechtigungen zuzuweisen. War {0}" },
            { "compiler.misc.canonical.with.name.mismatch", "Ung\u00FCltige Parameternamen in kanonischem Konstruktor" },
            { "compiler.misc.cant.access.inner.cls.constr", "Zugriff auf Konstruktor {0}({1}) nicht m\u00F6glich\nEinschlie\u00DFende Instanz vom Typ {2} ist nicht im Geltungsbereich" },
            { "compiler.misc.cant.apply.array.ctor", "Array kann nicht aus angegebenen Typen erstellt werden\nErforderlich: {0}\nErmittelt: {1}\nGrund: {2}" },
            { "compiler.misc.cant.apply.diamond.1", "Typargumente f\u00FCr {0} k\u00F6nnen nicht abgeleitet werden\nGrund: {1}" },
            { "compiler.misc.cant.apply.symbol", "{0} {1} in {4} {5} kann nicht auf die angegebenen Typen angewendet werden\nErforderlich: {2}\nErmittelt:    {3}\nGrund: {6}" },
            { "compiler.misc.cant.apply.symbols", "{0} f\u00FCr {1}({2}) nicht geeignet" },
            { "compiler.misc.cant.hide", "{0} in {1} kann nicht {2} in {3} ausblenden" },
            { "compiler.misc.cant.implement", "{0} in {1} kann nicht {2} in {3} implementieren" },
            { "compiler.misc.cant.override", "{0} in {1} kann nicht {2} in {3} au\u00DFer Kraft setzen" },
            { "compiler.misc.cant.resolve.args", "Symbol nicht gefunden\nSymbol: {0} {1}({3})" },
            { "compiler.misc.cant.resolve.location.args", "Symbol nicht gefunden\nSymbol: {0} {1}({3})\nOrt: {4}" },
            { "compiler.misc.cant.resolve.location.args.params", "Symbol nicht gefunden\nSymbol: {0} <{2}>{1}({3})\nOrt: {4}" },
            { "compiler.misc.cant.resolve.modules", "Module k\u00F6nnen nicht aufgel\u00F6st werden" },
            { "compiler.misc.captured.type", "CAP#{0}" },
            { "compiler.misc.clashes.with", "{0} in {1} steht mit {2} in {3} in Konflikt" },
            { "compiler.misc.class.file.not.found", "Klassendatei f\u00FCr {0} nicht gefunden" },
            { "compiler.misc.class.file.wrong.class", "Klassendatei enth\u00E4lt falsche Klasse: {0}" },
            { "compiler.misc.class.is.not.sealed", "{0} muss verschl\u00FCsselt sein" },
            { "compiler.misc.compact", "Kompakt" },
            { "compiler.misc.conditional.target.cant.be.void", "target-type f\u00FCr Bedingungsausdruck darf nicht \"void\" sein" },
            { "compiler.misc.count.error", "{0} Fehler" },
            { "compiler.misc.count.error.plural", "{0} Fehler" },
            { "compiler.misc.count.error.recompile", "Nur die ersten {0} Fehler von insgesamt {1} werden angezeigt. Mit -Xmaxerrs k\u00F6nnen Sie mehr Fehler anzeigen" },
            { "compiler.misc.count.warn", "{0} Warnung" },
            { "compiler.misc.count.warn.plural", "{0} Warnungen" },
            { "compiler.misc.count.warn.recompile", "Nur die ersten {0} Warnungen von insgesamt {1} werden angezeigt. Mit -Xmaxwarns k\u00F6nnen Sie mehr Warnungen anzeigen" },
            { "compiler.misc.descriptor", "Deskriptor: {2} {0}({1})" },
            { "compiler.misc.descriptor.throws", "Deskriptor: {2} {0}({1}) l\u00F6st {3} aus" },
            { "compiler.misc.diamond", "{0}<>" },
            { "compiler.misc.diamond.and.explicit.params", "\"<>\" kann nicht mit expliziten Typparametern f\u00FCr Konstruktor verwendet werden" },
            { "compiler.misc.diamond.anonymous.methods.implicitly.override", "(aufgrund von <> muss jede nicht private Methode, die in dieser anonymen Klasse deklariert ist, eine Methode aus einem Supertyp au\u00DFer Kraft setzen oder implementieren)" },
            { "compiler.misc.diamond.invalid.arg", "Typargument {0}, das f\u00FCr {1} abgeleitet wurde, ist in diesem Kontext nicht zul\u00E4ssig\nDas abgeleitete Argument kann nicht im Signaturattribut ausgedr\u00FCckt werden" },
            { "compiler.misc.diamond.invalid.args", "Typargumente {0}, die f\u00FCr {1} abgeleitet wurden, sind in diesem Kontext nicht zul\u00E4ssig\nAbgeleitete Argumente k\u00F6nnen nicht im Signaturattribut ausgedr\u00FCckt werden" },
            { "compiler.misc.diamond.non.generic", "\"<>\" kann nicht mit der nicht generischen Klasse {0} verwendet werden" },
            { "compiler.misc.doesnt.extend.sealed", "Unterklasse {0} muss verschl\u00FCsselte Klasse erweitern" },
            { "compiler.misc.eq.bounds", "Gleichheits-Constraints: {0}" },
            { "compiler.misc.exception.message", "{0}" },
            { "compiler.misc.explicit.param.do.not.conform.to.bounds", "Explizites Typargument {0} entspricht nicht den deklarierten Grenzwerten {1}" },
            { "compiler.misc.fatal.err.cant.close", "Schwerwiegender Fehler: Compiler-Ressourcen k\u00F6nnen nicht geschlossen werden" },
            { "compiler.misc.fatal.err.cant.locate.ctor", "Schwerwiegender Fehler: Konstruktor f\u00FCr {0} kann nicht gefunden werden" },
            { "compiler.misc.fatal.err.cant.locate.field", "Schwerwiegender Fehler: Feld {0} kann nicht gefunden werden" },
            { "compiler.misc.fatal.err.cant.locate.meth", "Schwerwiegender Fehler: Methode {0} kann nicht gefunden werden" },
            { "compiler.misc.feature.case.null", "Null in Switch Cases" },
            { "compiler.misc.feature.deconstruction.patterns", "Dekonstruktionsmuster" },
            { "compiler.misc.feature.diamond.and.anon.class", "\"<>\" mit anonymen inneren Klassen" },
            { "compiler.misc.feature.modules", "Module" },
            { "compiler.misc.feature.multiple.case.labels", "Mehrere CASE-Labels" },
            { "compiler.misc.feature.not.supported.in.source", "{0} wird in -source {1} nicht unterst\u00FCtzt\n(Verwenden Sie -source {2} oder h\u00F6her, um {0} zu aktivieren)" },
            { "compiler.misc.feature.not.supported.in.source.plural", "{0} werden in -source {1} nicht unterst\u00FCtzt\n(Verwenden Sie -source {2} oder h\u00F6her, um {0} zu aktivieren)" },
            { "compiler.misc.feature.pattern.matching.instanceof", "Musterabgleich in instanceof" },
            { "compiler.misc.feature.pattern.switch", "Muster in Switch-Anweisungen" },
            { "compiler.misc.feature.private.intf.methods", "Private Schnittstellenmethoden" },
            { "compiler.misc.feature.records", "Datens\u00E4tze" },
            { "compiler.misc.feature.reifiable.types.instanceof", "Reifizierbare Typen in instanceof" },
            { "compiler.misc.feature.sealed.classes", "Verschl\u00FCsselte Klassen" },
            { "compiler.misc.feature.string.templates", "Zeichenfolgenvorlagen" },
            { "compiler.misc.feature.switch.expressions", "Switch-Ausdr\u00FCcke" },
            { "compiler.misc.feature.switch.rules", "Switch-Regeln" },
            { "compiler.misc.feature.text.blocks", "Textbl\u00F6cke" },
            { "compiler.misc.feature.unconditional.patterns.in.instanceof", "Nicht bedingte Muster in instanceof" },
            { "compiler.misc.feature.unnamed.classes", "Unbenannte Klassen" },
            { "compiler.misc.feature.unnamed.variables", "Unbenannte Variablen" },
            { "compiler.misc.feature.var.in.try.with.resources", "Variablen in try-with-resources" },
            { "compiler.misc.feature.var.syntax.in.implicit.lambda", "var-Syntax in impliziten Lambdas" },
            { "compiler.misc.file.does.not.contain.module", "Datei enth\u00E4lt keine Moduldeklaration" },
            { "compiler.misc.file.does.not.contain.package", "Datei enth\u00E4lt nicht Package {0}" },
            { "compiler.misc.file.doesnt.contain.class", "Datei enth\u00E4lt nicht Klasse {0}" },
            { "compiler.misc.guard", "Guard" },
            { "compiler.misc.illegal.flag.combo", "Klassendatei enth\u00E4lt unzul\u00E4ssige Kennzeichenkombination {0} f\u00FCr {1} {2}" },
            { "compiler.misc.illegal.signature", "Unzul\u00E4ssiges Signaturattribut f\u00FCr Typ {1}" },
            { "compiler.misc.illegal.start.of.class.file", "Unzul\u00E4ssiger Klassendateibeginn" },
            { "compiler.misc.implicit.and.explicit.not.allowed", "Implizit typisierte Parameter k\u00F6nnen nicht mit explizit typisierten Parametern gemischt werden" },
            { "compiler.misc.inaccessible.varargs.type", "Auf den formalen varargs-Elementtyp {0} kann nicht von {1} {2} zugegriffen werden" },
            { "compiler.misc.inapplicable.method", "{0} {1}.{2} ist nicht anwendbar\n({3})" },
            { "compiler.misc.incompatible.abstract.default", "{0} {1} erbt abstrakte und Standardmethode f\u00FCr {2}({3}) von Typen {4} und {5}" },
            { "compiler.misc.incompatible.abstracts", "Mehrere nicht \u00FCberschreibende abstrakte Methoden in {0} {1} gefunden" },
            { "compiler.misc.incompatible.arg.types.in.lambda", "Inkompatible Parametertypen in Lambda-Ausdruck" },
            { "compiler.misc.incompatible.arg.types.in.mref", "Inkompatible Parametertypen in Methodenreferenz" },
            { "compiler.misc.incompatible.bounds", "Inferenzvariable {0} hat inkompatible Grenzwerte\n{1}\n{2}" },
            { "compiler.misc.incompatible.descs.in.functional.intf", "Inkompatible Funktionsdeskriptoren in {0} {1} gefunden" },
            { "compiler.misc.incompatible.diff.ret", "Beide definieren {0}({1}), aber mit nicht verwandten R\u00FCckgabetypen" },
            { "compiler.misc.incompatible.eq.bounds", "Inferenzvariable {0} hat inkompatible Gleichheits-Constraints {1}" },
            { "compiler.misc.incompatible.ret.type.in.lambda", "Ung\u00FCltiger R\u00FCckgabetyp in Lambda-Ausdruck\n{0}" },
            { "compiler.misc.incompatible.ret.type.in.mref", "Ung\u00FCltiger R\u00FCckgabetyp in Methodenreferenz\n{0}" },
            { "compiler.misc.incompatible.type.in.conditional", "Ung\u00FCltiger Typ in Bedingungsausdruck\n{0}" },
            { "compiler.misc.incompatible.type.in.switch.expression", "Ung\u00FCltiger Typ in Switch-Ausdruck\n{0}" },
            { "compiler.misc.incompatible.unrelated.defaults", "{0} {1} erbt nicht verwandte Standardwerte f\u00FCr {2}({3}) von Typen {4} und {5}" },
            { "compiler.misc.incompatible.upper.bounds", "Inferenzvariable {0} hat inkompatible obere Grenzwerte {1}" },
            { "compiler.misc.inconvertible.types", "{0} kann nicht in {1} konvertiert werden" },
            { "compiler.misc.infer.arg.length.mismatch", "Typvariable(n) {0} nicht ableitbar\n(Liste der tats\u00E4chlichen Argumente hat eine andere L\u00E4nge als die der formalen Argumente)" },
            { "compiler.misc.infer.no.conforming.assignment.exists", "Typvariable(n) {0} nicht ableitbar\n(nicht \u00FCbereinstimmende Argumente; {1})" },
            { "compiler.misc.infer.no.conforming.instance.exists", "Keine Instanzen von Typvariablen {0} vorhanden, sodass {1} {2} entspricht" },
            { "compiler.misc.infer.varargs.argument.mismatch", "Typvariable(n) {0} nicht ableitbar\n(nicht \u00FCbereinstimmende varargs, {1})" },
            { "compiler.misc.inferred.do.not.conform.to.eq.bounds", "Abgeleiteter Typ entspricht nicht den Gleichheits-Constraints\nAbgeleitet: {0}\nGleichheits-Constraint(s): {1}" },
            { "compiler.misc.inferred.do.not.conform.to.lower.bounds", "Abgeleiteter Typ entspricht nicht den unteren Grenzwerten\nAbgeleitet: {0}\nUntere Grenzwerte: {1}" },
            { "compiler.misc.inferred.do.not.conform.to.upper.bounds", "Abgeleiteter Typ entspricht nicht den oberen Grenzwerten\nAbgeleitet: {0}\nObere Grenzwerte: {1}" },
            { "compiler.misc.inner.cls", "Innere Klasse" },
            { "compiler.misc.intersection.type", "INT#{0}" },
            { "compiler.misc.invalid.default.interface", "Standardmethode in Klassendatei der Version {0}.{1} gefunden" },
            { "compiler.misc.invalid.generic.lambda.target", "Ung\u00FCltiger Funktionsdeskriptor f\u00FCr Lambda-Ausdruck\nMethode {0} in {1} {2} ist generisch" },
            { "compiler.misc.invalid.mref", "Ung\u00FCltige {0}-Referenz\n{1}" },
            { "compiler.misc.invalid.static.interface", "Statische Methode in Klassendatei der Version {0}.{1} gefunden" },
            { "compiler.misc.is.a.type.variable", "Darf keine Typvariablen enthalten: {0}" },
            { "compiler.misc.is.duplicated", "Darf keine Duplikate enthalten: {0}" },
            { "compiler.misc.kindname.annotation", "@interface" },
            { "compiler.misc.kindname.class", "Klasse" },
            { "compiler.misc.kindname.constructor", "Konstruktor" },
            { "compiler.misc.kindname.enum", "Enumeration" },
            { "compiler.misc.kindname.instance.init", "Instanz-Initializer" },
            { "compiler.misc.kindname.interface", "Schnittstelle" },
            { "compiler.misc.kindname.method", "Methode" },
            { "compiler.misc.kindname.module", "Modul" },
            { "compiler.misc.kindname.package", "Package" },
            { "compiler.misc.kindname.record", "Datensatz" },
            { "compiler.misc.kindname.record.component", "Datensatzkomponente" },
            { "compiler.misc.kindname.static", "statisch" },
            { "compiler.misc.kindname.static.init", "statischer Initializer" },
            { "compiler.misc.kindname.type.variable", "Typvariable" },
            { "compiler.misc.kindname.type.variable.bound", "Grenzwert von Typvariable" },
            { "compiler.misc.kindname.value", "Wert" },
            { "compiler.misc.kindname.variable", "Variable" },
            { "compiler.misc.lambda", "Lambda-Ausdruck" },
            { "compiler.misc.local", "Lokal" },
            { "compiler.misc.local.array.missing.target", "Array-Initializer erfordert einen expliziten Zieltyp" },
            { "compiler.misc.local.cant.infer.null", "Variablen-Initializer ist \"null\"" },
            { "compiler.misc.local.cant.infer.void", "Variablen-Initializer ist \"void\"" },
            { "compiler.misc.local.lambda.missing.target", "Lambda-Ausdruck erfordert einen expliziten Zieltyp" },
            { "compiler.misc.local.missing.init", "\"var\" kann nicht f\u00FCr Variable ohne Initializer verwendet werden" },
            { "compiler.misc.local.mref.missing.target", "Methodenreferenz erfordert einen expliziten Zieltyp" },
            { "compiler.misc.local.self.ref", "\"var\" kann nicht f\u00FCr selbstreferenzierende Variable verwendet werden" },
            { "compiler.misc.location", "{0} {1}" },
            { "compiler.misc.location.1", "{0} {1} von Typ {2}" },
            { "compiler.misc.locn.module_path", "Anwendungsmodulpfad" },
            { "compiler.misc.locn.module_source_path", "Modulquellpfad" },
            { "compiler.misc.locn.system_modules", "Systemmodule" },
            { "compiler.misc.locn.upgrade_module_path", "Upgrademodulpfad" },
            { "compiler.misc.lower.bounds", "Untere Grenzwerte: {0}" },
            { "compiler.misc.malformed.vararg.method", "Klassendatei enth\u00E4lt nicht wohlgeformte Methode mit variabler Argumentanzahl: {0}" },
            { "compiler.misc.method.descriptor.invalid", "Methodendeskriptor ung\u00FCltig f\u00FCr {0}" },
            { "compiler.misc.method.must.be.public", "Accessor-Methode muss \u00F6ffentlich sein" },
            { "compiler.misc.missing.ret.val", "R\u00FCckgabewert fehlt" },
            { "compiler.misc.module.info.definition.expected", "module-info-Definition erwartet" },
            { "compiler.misc.module.info.invalid.super.class", "module-info mit ung\u00FCltiger Superklasse" },
            { "compiler.misc.module.name.mismatch", "Modulname {0} stimmt nicht mit dem erwarteten Namen {1} \u00FCberein" },
            { "compiler.misc.module.non.zero.opens", "Bei ge\u00F6ffnetem Modul {0} ist opens_count ungleich Null" },
            { "compiler.misc.mref.infer.and.explicit.params", "Raw-Konstruktorreferenz kann nicht mit expliziten Typparametern f\u00FCr Konstruktor verwendet werden" },
            { "compiler.misc.must.not.be.same.class", "Unzul\u00E4ssige Selbstreferenz in PERMITS-Klausel" },
            { "compiler.misc.must.not.be.supertype", "Unzul\u00E4ssige Referenz zu Supertyp {0}" },
            { "compiler.misc.no.abstracts", "Keine abstrakte Methode in {0} {1} gefunden" },
            { "compiler.misc.no.args", "keine Argumente" },
            { "compiler.misc.no.conforming.assignment.exists", "Keine \u00FCbereinstimmenden Argumente, {0}" },
            { "compiler.misc.no.suitable.functional.intf.inst", "Funktionsschnittstellendeskriptor f\u00FCr {0} kann nicht abgeleitet werden" },
            { "compiler.misc.no.unique.maximal.instance.exists", "Keine eindeutige maximale Instanz f\u00FCr Typvariable {0} mit oberen Grenzwerten {1} vorhanden" },
            { "compiler.misc.no.unique.minimal.instance.exists", "Keine eindeutige minimale Instanz f\u00FCr Typvariable {0} mit unteren Grenzwerten {1} vorhanden" },
            { "compiler.misc.non.static", "nicht statisch" },
            { "compiler.misc.not.a.functional.intf", "{0} ist keine Funktionsschnittstelle" },
            { "compiler.misc.not.a.functional.intf.1", "{0} ist keine Funktionsschnittstelle\n{1}" },
            { "compiler.misc.not.an.intf.component", "Komponententyp {0} ist keine Schnittstelle" },
            { "compiler.misc.not.applicable.method.found", "#{0} nicht anwendbare Methode gefunden: {1}\n({2})" },
            { "compiler.misc.not.applicable.types", "Muster des Typs {1} ist bei {0} nicht anwendbar" },
            { "compiler.misc.not.def.access.class.intf.cant.access", "{1}.{0} ist in einer nicht zug\u00E4nglichen Klasse oder Schnittstelle definiert" },
            { "compiler.misc.not.def.access.class.intf.cant.access.reason", "{1}.{0} in Package {2} ist nicht zug\u00E4nglich\n({3})" },
            { "compiler.misc.not.def.access.does.not.read", "Package {1} wird in Modul {2} deklariert, aber nicht von Modul {0} gelesen" },
            { "compiler.misc.not.def.access.does.not.read.from.unnamed", "Package {0} wird in Modul {1} deklariert, das nicht im Moduldiagramm enthalten ist" },
            { "compiler.misc.not.def.access.does.not.read.unnamed", "Package {0} wird im unbenannten Modul deklariert, aber nicht von Modul {1} gelesen" },
            { "compiler.misc.not.def.access.not.exported", "Package {0} wird in Modul {1} deklariert, aber nicht exportiert" },
            { "compiler.misc.not.def.access.not.exported.from.unnamed", "Package {0} wird in Modul {1} deklariert, aber nicht exportiert" },
            { "compiler.misc.not.def.access.not.exported.to.module", "Package {0} wird in Modul {1} deklariert, aber nicht in Modul {2} exportiert" },
            { "compiler.misc.not.def.access.not.exported.to.module.from.unnamed", "Package {0} wird in Modul {1} deklariert, aber nicht in das unbenannte Modul exportiert" },
            { "compiler.misc.not.def.access.package.cant.access", "{0} ist nicht sichtbar\n({2})" },
            { "compiler.misc.not.def.public.cant.access", "{0} ist nicht \u00F6ffentlich in {1}. Zugriff von externem Package nicht m\u00F6glich" },
            { "compiler.misc.overridden.default", "Methode {0} wird in {1} au\u00DFer Kraft gesetzt" },
            { "compiler.misc.package.not.visible", "Package {0} ist nicht sichtbar\n({1})" },
            { "compiler.misc.partial.inst.sig", "Teilweise instanziiert in: {0}" },
            { "compiler.misc.possible.loss.of.precision", "M\u00F6glicher Verlust bei Konvertierung von {0} in {1}" },
            { "compiler.misc.prob.found.req", "Inkompatible Typen: {0}" },
            { "compiler.misc.redundant.supertype", "Redundante Schnittstelle {0} wird durch {1} erweitert" },
            { "compiler.misc.ref.ambiguous", "Referenz zu {0} ist mehrdeutig\nSowohl {1} {2} in {3} als auch {4} {5} in {6} stimmen \u00FCberein" },
            { "compiler.misc.report.access", "{0} hat {1}-Zugriff in {2}" },
            { "compiler.misc.resume.abort", "F)ortsetzen, A)bbruch>" },
            { "compiler.misc.source.unavailable", "(Quelle nicht verf\u00FCgbar)" },
            { "compiler.misc.stat.expr.expected", "Lambda-Body ist nicht mit einer void-Funktionsschnittstelle kompatibel\n(verwenden Sie stattdessen einen Block-Lambda-Body oder einen Anweisungsausdruck)" },
            { "compiler.misc.static", "statisch" },
            { "compiler.misc.static.mref.with.targs", "Parametrisierter Qualifier f\u00FCr statische Methodenreferenz" },
            { "compiler.misc.switch.expression.target.cant.be.void", "target-type f\u00FCr Switch-Ausdruck darf nicht \"void\" sein" },
            { "compiler.misc.synthetic.name.conflict", "Das Symbol {0} steht mit einem vom Compiler synthetisierten Symbol in {1} in Konflikt" },
            { "compiler.misc.throws.clause.not.allowed.for.canonical.constructor", "Throws-Klausel f\u00FCr Konstruktor des Typs {0} nicht zul\u00E4ssig" },
            { "compiler.misc.token.bad-symbol", "<ung\u00FCltiges Symbol>" },
            { "compiler.misc.token.character", "<Zeichen>" },
            { "compiler.misc.token.double", "<Double>" },
            { "compiler.misc.token.end-of-input", "<Ende der Eingabe>" },
            { "compiler.misc.token.float", "<Float>" },
            { "compiler.misc.token.identifier", "<ID>" },
            { "compiler.misc.token.integer", "<Ganzzahl>" },
            { "compiler.misc.token.long-integer", "<Ganzzahl vom Typ \"long\">" },
            { "compiler.misc.token.string", "<Zeichenfolge>" },
            { "compiler.misc.try.not.applicable.to.type", "try-with-resources nicht auf Variablentyp anwendbar\n({0})" },
            { "compiler.misc.type.captureof", "capture#{0} von {1}" },
            { "compiler.misc.type.captureof.1", "capture#{0}" },
            { "compiler.misc.type.must.be.identical.to.corresponding.record.component.type", "Typ und Argumentanzahl m\u00FCssen mit den Werten der entsprechenden Datensatzkomponente \u00FCbereinstimmen" },
            { "compiler.misc.type.none", "<kein Wert>" },
            { "compiler.misc.type.null", "<Null>" },
            { "compiler.misc.type.parameter", "Typparameter {0}" },
            { "compiler.misc.type.req.array.or.iterable", "Array oder java.lang.Iterable" },
            { "compiler.misc.type.req.class", "Klasse" },
            { "compiler.misc.type.req.class.array", "Klasse oder Array" },
            { "compiler.misc.type.req.exact", "Klasse oder Schnittstelle ohne Grenzwerte" },
            { "compiler.misc.type.req.ref", "Referenz" },
            { "compiler.misc.type.var", "{0}#{1}" },
            { "compiler.misc.unable.to.access.file", "Zugriff auf Datei nicht m\u00F6glich: {0}" },
            { "compiler.misc.unbound", "ungebunden" },
            { "compiler.misc.unchecked.assign", "Nicht gepr\u00FCfte Konvertierung" },
            { "compiler.misc.unchecked.cast.to.type", "Nicht gepr\u00FCftes Casting" },
            { "compiler.misc.unchecked.clash.with", "{0} in {1} setzt {2} in {3} au\u00DFer Kraft" },
            { "compiler.misc.unchecked.implement", "{0} in {1} implementiert {2} in {3}" },
            { "compiler.misc.unchecked.override", "{0} in {1} setzt {2} in {3} au\u00DFer Kraft" },
            { "compiler.misc.undecl.type.var", "Nicht deklarierte Typvariable: {0}" },
            { "compiler.misc.unexpected.const.pool.tag.at", "Unerwartetes Konstantenpooltag {0} bei {1}" },
            { "compiler.misc.unexpected.ret.val", "Unerwarteter R\u00FCckgabewert" },
            { "compiler.misc.unicode.str.not.supported", "Unicode-Zeichenfolge wird in Klassendatei nicht unterst\u00FCtzt" },
            { "compiler.misc.unnamed.module", "Unbenanntes Modul" },
            { "compiler.misc.unnamed.package", "Unbenanntes Package" },
            { "compiler.misc.upper.bounds", "Obere Grenzen: {0}" },
            { "compiler.misc.user.selected.completion.failure", "Von Benutzer ausgew\u00E4hlter Abschlussfehler nach Klassenname" },
            { "compiler.misc.var.and.explicit.not.allowed", "\"var\" kann nicht mit explizit typisierten Parametern gemischt werden" },
            { "compiler.misc.var.and.implicit.not.allowed", "\"var\" kann nicht mit implizit typisierten Parametern gemischt werden" },
            { "compiler.misc.varargs.argument.mismatch", "Keine \u00FCbereinstimmenden varargs; {0}" },
            { "compiler.misc.varargs.clash.with", "{0} in {1} setzt {2} in {3} au\u00DFer Kraft" },
            { "compiler.misc.varargs.implement", "{0} in {1} implementiert {2} in {3}" },
            { "compiler.misc.varargs.override", "{0} in {1} setzt {2} in {3} au\u00DFer Kraft" },
            { "compiler.misc.varargs.trustme.on.non.varargs.accessor", "Accessor {0} ist keine varargs-Methode." },
            { "compiler.misc.varargs.trustme.on.non.varargs.meth", "Methode {0} ist keine varargs-Methode." },
            { "compiler.misc.varargs.trustme.on.reifiable.varargs", "Varargs-Elementtyp {0} ist reifizierbar." },
            { "compiler.misc.varargs.trustme.on.virtual.varargs", "Instanzmethode {0} ist weder final noch privat." },
            { "compiler.misc.varargs.trustme.on.virtual.varargs.final.only", "Instanzmethode {0} ist nicht final." },
            { "compiler.misc.verbose.checking.attribution", "[{0} wird gepr\u00FCft]" },
            { "compiler.misc.verbose.classpath", "[Suchpfad f\u00FCr Klassendateien: {0}]" },
            { "compiler.misc.verbose.loading", "[{0} wird geladen]" },
            { "compiler.misc.verbose.parsing.done", "[Parsen abgeschlossen: {0} ms]" },
            { "compiler.misc.verbose.parsing.started", "[Parsen gestartet: {0}]" },
            { "compiler.misc.verbose.sourcepath", "[Suchpfad f\u00FCr Quelldateien: {0}]" },
            { "compiler.misc.verbose.total", "[{0} ms gesamt]" },
            { "compiler.misc.verbose.wrote.file", "[{0} geschrieben]" },
            { "compiler.misc.version.not.available", "(Versionsinformationen nicht verf\u00FCgbar)" },
            { "compiler.misc.where.captured", "{0} erweitert {1} Super: {2} aus Erfassung von {3}" },
            { "compiler.misc.where.captured.1", "{0} erweitert {1} aus Erfassung von {3}" },
            { "compiler.misc.where.description.captured", "Dabei ist {0} eine neue Typvariable:" },
            { "compiler.misc.where.description.captured.1", "Dabei sind {0} neue Typvariablen:" },
            { "compiler.misc.where.description.intersection", "Dabei ist {0} ein Schnittmengentyp:" },
            { "compiler.misc.where.description.intersection.1", "Dabei sind {0} Schnittmengentypen:" },
            { "compiler.misc.where.description.typevar", "Dabei ist {0} eine Typvariable:" },
            { "compiler.misc.where.description.typevar.1", "Dabei sind {0} Typvariablen:" },
            { "compiler.misc.where.fresh.typevar", "{0} erweitert {1}" },
            { "compiler.misc.where.intersection", "{0} erweitert {1}" },
            { "compiler.misc.where.typevar", "{0} erweitert {1}, deklariert in {2} {3}" },
            { "compiler.misc.where.typevar.1", "{0} deklariert in {2} {3}" },
            { "compiler.misc.wrong.number.type.args", "Falsche Anzahl Typargumente. {0} erforderlich" },
            { "compiler.misc.wrong.version", "Klassendatei hat die falsche Version {0}.{1}. Sie muss {2}.{3} lauten" },
            { "compiler.misc.x.print.processor.info", "Prozessor {0} entspricht {1} und gibt {2} zur\u00FCck." },
            { "compiler.misc.x.print.rounds", "Runde {0}:\n\tEingabedateien: {1}\n\tAnnotationen: {2}\n\tLetzte Runde: {3}" },
            { "compiler.note.compressed.diags", "Einige Meldungen wurden vereinfacht. Wiederholen Sie die Kompilierung mit -Xdiags:verbose, um die vollst\u00E4ndige Ausgabe abzurufen" },
            { "compiler.note.deferred.method.inst", "Instanziierung von Methode {0} verz\u00F6gert\nInstanziierte Signatur: {1}\ntarget-type: {2}" },
            { "compiler.note.deprecated.filename", "{0} verwendet oder \u00FCberschreibt eine veraltete API." },
            { "compiler.note.deprecated.filename.additional", "{0} hat weitere Verwendungen oder Overrides einer veralteten API." },
            { "compiler.note.deprecated.plural", "Einige Eingabedateien verwenden oder \u00FCberschreiben eine veraltete API." },
            { "compiler.note.deprecated.plural.additional", "Einige Eingabedateien verwenden oder \u00FCberschreiben zus\u00E4tzlich eine veraltete API." },
            { "compiler.note.deprecated.recompile", "Wiederholen Sie die Kompilierung mit -Xlint:deprecation, um Details zu erhalten." },
            { "compiler.note.implicit.annotation.processing", "Die Annotationsverarbeitung ist aktiviert, da mindestens ein Prozessor im\nClasspath gefunden wurde. In einem zuk\u00FCnftigen Release von javac kann die Annotationsverarbeitung deaktiviert werden,\nes sei denn, mindestens ein Prozessor ist namentlich angegeben (-processor), oder ein Suchpfad\nist angegeben (--processor-path, --processor-module-path), oder die Annotationsverarbeitung\nwurde explizit aktiviert (-proc:only, -proc:full).\nVerwenden Sie \"-Xlint:-options\", um diese Meldung zu unterdr\u00FCcken.\nVerwenden Sie \"-proc:none\", um die Annotationsverarbeitung zu deaktivieren." },
            { "compiler.note.lambda.stat", "Lambda-Ausdruck wird \u00FCbersetzt\nAlternative Metafactory = {0}\nSynthetische Methode = {1}" },
            { "compiler.note.method.ref.search.results.multi", "{0} Suchergebnisse f\u00FCr {1}, mit spezifischsten {2}\nAnwendbare Kandidaten:" },
            { "compiler.note.mref.stat", "Methodenreferenz wird \u00FCbersetzt\nAlternative Metafactory = {0}\n" },
            { "compiler.note.mref.stat.1", "Methodenreferenz wird \u00FCbersetzt\nAlternative Metafactory = {0}\nBridgemethode = {1}" },
            { "compiler.note.multiple.elements", "Mehrere Elemente namens \"{1}\" in Modulen \"{2}\" wurden von javax.lang.model.util.Elements.{0} gefunden." },
            { "compiler.note.note", "Hinweis: " },
            { "compiler.note.preview.filename", "{0} verwendet Vorschaufeatures von Java SE {1}." },
            { "compiler.note.preview.filename.additional", "{0} hat weitere Verwendungen von Vorschaufeatures von Java SE {1}." },
            { "compiler.note.preview.plural", "Einige Eingabedateien verwenden Vorschaufeatures von Java SE {0}." },
            { "compiler.note.preview.plural.additional", "Einige Eingabedateien verwenden zus\u00E4tzlich Vorschaufeatures von Java SE {0}." },
            { "compiler.note.preview.recompile", "Wiederholen Sie die Kompilierung mit -Xlint:preview, um Details zu erhalten." },
            { "compiler.note.proc.messager", "{0}" },
            { "compiler.note.removal.filename", "{0} verwendet oder \u00FCberschreibt eine veraltete API, die zum Entfernen markiert ist." },
            { "compiler.note.removal.filename.additional", "{0} hat weitere Verwendungen oder Overrides einer veralteten API, die zum Entfernen markiert ist." },
            { "compiler.note.removal.plural", "Einige Eingabedateien verwenden oder \u00FCberschreiben eine veraltete API, die zum Entfernen markiert ist." },
            { "compiler.note.removal.plural.additional", "Einige Eingabedateien verwenden oder \u00FCberschreiben zus\u00E4tzlich eine veraltete API, die zum Entfernen markiert ist." },
            { "compiler.note.removal.recompile", "Wiederholen Sie die Kompilierung mit -Xlint:removal, um Details zu erhalten." },
            { "compiler.note.unchecked.filename", "{0} verwendet nicht gepr\u00FCfte oder unsichere Vorg\u00E4nge." },
            { "compiler.note.unchecked.filename.additional", "{0} weist weitere nicht gepr\u00FCfte oder unsichere Vorg\u00E4nge auf." },
            { "compiler.note.unchecked.plural", "Einige Eingabedateien verwenden nicht gepr\u00FCfte oder unsichere Vorg\u00E4nge." },
            { "compiler.note.unchecked.plural.additional", "Einige Eingabedateien verwenden zus\u00E4tzlich nicht gepr\u00FCfte oder unsichere Vorg\u00E4nge." },
            { "compiler.note.unchecked.recompile", "Wiederholen Sie die Kompilierung mit -Xlint:unchecked, um Details zu erhalten." },
            { "compiler.note.verbose.l2m.deduplicate", "Lambda-Implementierungsmethode {0} wird dedupliziert" },
            { "compiler.note.verbose.resolve.multi", "Methode {0} wird in Typ {1} als Kandidat {2} aufgel\u00F6st\nPhase: {3}\nMit Istwerten: {4}\nMit type-args: {5}\nKandidaten:" },
            { "compiler.note.verbose.resolve.multi.1", "Fehlerhafte Aufl\u00F6sung f\u00FCr Methode {0} in Typ {1}\nPhase: {3}\nMit Istwerten: {4}\nMit type-args: {5}\nKandidaten:" },
            { "compiler.warn.OSF.array.SPF", "serialPersistentFields muss den Typ \"java.io.ObjectStreamField[]\" aufweisen, um in Kraft zu treten" },
            { "compiler.warn.SPF.null.init", "serialPersistentFields tritt bei Initialisierung als Null nicht in Kraft.\nF\u00FChren Sie die Initialisierung zu einem leeren Array aus, um keine Felder anzugeben" },
            { "compiler.warn.access.to.member.from.serializable.element", "Zugriff auf Mitglied {0} aus serialisierbarem Element kann \u00F6ffentlich f\u00FCr nicht vertrauensw\u00FCrdigen Code zug\u00E4nglich sein" },
            { "compiler.warn.access.to.member.from.serializable.lambda", "Zugriff auf Mitglied {0} aus serialisierbarem Lambda kann \u00F6ffentlich f\u00FCr nicht vertrauensw\u00FCrdigen Code zug\u00E4nglich sein" },
            { "compiler.warn.addopens.ignored", "--add-opens hat zur Kompilierungszeit keine Auswirkungen" },
            { "compiler.warn.annotation.method.not.found", "Annotationsmethode \"{1}()\" kann nicht in Typ \"{0}\" gefunden werden" },
            { "compiler.warn.annotation.method.not.found.reason", "Annotationsmethode \"{1}()\" kann nicht in Typ \"{0}\" gefunden werden: {2}" },
            { "compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class", "Versuch der Synchronisierung f\u00FCr eine Instanz einer wertbasierten Klasse" },
            { "compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file", "Auf Auxiliary-Klasse {0} in {1} darf nicht von au\u00DFerhalb der eigenen Quelldatei zugegriffen werden" },
            { "compiler.warn.bad.name.for.option", "Ung\u00FCltiger Name im Wert f\u00FCr {0}-Option: \"{1}\"" },
            { "compiler.warn.big.major.version", "{0}: Hauptversion {1} ist neuer als {2}, die h\u00F6chste Hauptversion, die von diesem Compiler unterst\u00FCtzt wird.\nEs wird empfohlen, dass Sie den Compiler upgraden." },
            { "compiler.warn.constant.SVUID", "serialVersionUID muss Konstante in Klasse {0} sein" },
            { "compiler.warn.declared.using.preview", "{0} {1} ist mit einem Vorschaufeature deklariert, das in einem zuk\u00FCnftigen Release entfernt werden kann." },
            { "compiler.warn.default.ineffective", "Serialisierungsbezogene Standardmethode aus einer Schnittstelle wird nicht von der Serialisierung f\u00FCr eine implementierende Klasse ausgef\u00FChrt" },
            { "compiler.warn.deprecated.annotation.has.no.effect", "@Deprecated-Annotation hat keine Auswirkung auf diese {0}-Deklaration" },
            { "compiler.warn.diamond.redundant.args", "Redundante Typargumente in neuem Ausdruck (verwenden Sie stattdessen den Rautenoperator)." },
            { "compiler.warn.dir.path.element.not.directory", "Ung\u00FCltiges Pfadelement \"{0}\": kein Verzeichnis" },
            { "compiler.warn.dir.path.element.not.found", "Ung\u00FCltiges Pfadelement \"{0}\": Verzeichnis nicht vorhanden" },
            { "compiler.warn.div.zero", "Division durch Null" },
            { "compiler.warn.doclint.not.available", "Kein Serviceprovider f\u00FCr doclint verf\u00FCgbar" },
            { "compiler.warn.empty.if", "Leere Anweisung nach \"if\"" },
            { "compiler.warn.externalizable.missing.public.no.arg.ctor", "Eine externalisierbare Klasse erfordert einen \u00F6ffentlichen no-arg-Konstruktor" },
            { "compiler.warn.extraneous.semicolon", "\u00DCberfl\u00FCssiges Semikolon" },
            { "compiler.warn.file.from.future", "\u00C4nderungsdatum liegt in der Zukunft f\u00FCr Datei {0}" },
            { "compiler.warn.finally.cannot.complete", "Finally-Klausel kann nicht normal abgeschlossen werden" },
            { "compiler.warn.forward.ref", "Referenz zu Variable \"{0}\", bevor sie initialisiert wurde" },
            { "compiler.warn.future.attr", "{0}-Attribut, das in Klassendateien der Version {1}.{2} eingef\u00FChrt wurde, wird in Klassendateien der Version {3}.{4} ignoriert" },
            { "compiler.warn.has.been.deprecated", "{0} in {1} ist veraltet" },
            { "compiler.warn.has.been.deprecated.for.removal", "{0} in {1} ist veraltet und wurde zum Entfernen markiert" },
            { "compiler.warn.has.been.deprecated.for.removal.module", "Modul {0} ist veraltet und wurde zum Entfernen markiert" },
            { "compiler.warn.has.been.deprecated.module", "Modul {0} ist veraltet" },
            { "compiler.warn.illegal.char.for.encoding", "Nicht zuordenbares Zeichen f\u00FCr Codierung {0}" },
            { "compiler.warn.illegal.ref.to.restricted.type", "Unzul\u00E4ssige Referenz zu eingeschr\u00E4nktem Typ \"{0}\"" },
            { "compiler.warn.improper.SPF", "serialPersistentFields muss als \"private static final\" deklariert sein, um in Kraft zu treten" },
            { "compiler.warn.improper.SVUID", "serialVersionUID muss als \"static final\" in Klasse {0} deklariert sein" },
            { "compiler.warn.inconsistent.white.space.indentation", "Inkonsistenter Leerzeicheneinzug" },
            { "compiler.warn.incubating.modules", "Inkubatormodul(e) verwendet: {0}" },
            { "compiler.warn.ineffectual.extern.method.enum", "Externalisierungsbezogene Methode {0} ist in einer Enum-Klasse nicht effektiv" },
            { "compiler.warn.ineffectual.externalizable.method.record", "Externalisierungsbezogene Methode {0} ist in einer Datensatzklasse nicht effektiv" },
            { "compiler.warn.ineffectual.serial.field.enum", "Serialisierungsbezogenes Feld {0} ist in einer Enum-Klasse nicht effektiv" },
            { "compiler.warn.ineffectual.serial.field.externalizable", "serialPersistentFields ist in einer externalisierbaren Klasse nicht effektiv" },
            { "compiler.warn.ineffectual.serial.field.interface", "serialPersistentFields ist in einer Schnittstelle nicht effektiv" },
            { "compiler.warn.ineffectual.serial.field.record", "serialPersistentFields ist in einer Datensatzklasse nicht effektiv" },
            { "compiler.warn.ineffectual.serial.method.enum", "Serialisierungsbezogene Methode {0} ist in einer Enum-Klasse nicht effektiv" },
            { "compiler.warn.ineffectual.serial.method.externalizable", "Serialisierungsbezogene Methode {0} ist in einer externalisierbaren Klasse nicht effektiv" },
            { "compiler.warn.ineffectual.serial.method.record", "Serialisierungsbezogene Methode {0} ist in einer Datensatzklasse nicht effektiv" },
            { "compiler.warn.inexact.non-varargs.call", "Nicht-varargs-Aufruf von varargs-Methode mit ungenauem Argumenttyp f\u00FCr den letzten Parameter.\nF\u00FChren Sie f\u00FCr einen varargs-Aufruf eine Umwandlung mit Cast in {0} aus\nF\u00FChren Sie f\u00FCr einen Nicht-varargs-Aufruf eine Umwandlung mit Cast in {1} aus, um diese Warnung zu unterdr\u00FCcken" },
            { "compiler.warn.invalid.archive.file", "Unerwartete Datei in Pfad: {0}" },
            { "compiler.warn.invalid.path", "Ung\u00FCltiger Dateiname: {0}" },
            { "compiler.warn.invalid.utf8.in.classfile", "{0}: Klassendatei enth\u00E4lt ung\u00FCltige UTF-8-Codierung: {1}" },
            { "compiler.warn.invalid.yield", "\"yield\" kann in einem zuk\u00FCnftigen Release zu einer eingeschr\u00E4nkten ID werden\n(um eine Methode namens \"yield\" aufzurufen, qualifizieren Sie den yield-Aufruf mit einem Empf\u00E4nger oder Typnamen)" },
            { "compiler.warn.is.preview", "{0} ist eine Vorschau-API, die in einem zuk\u00FCnftigen Release entfernt werden kann." },
            { "compiler.warn.is.preview.reflective", "{0} ist eine reflektive Vorschau-API, die in einem zuk\u00FCnftigen Release entfernt werden kann." },
            { "compiler.warn.leaks.not.accessible", "{0} {1} in Modul {2} ist nicht zug\u00E4nglich f\u00FCr Clients, die dieses Modul ben\u00F6tigen" },
            { "compiler.warn.leaks.not.accessible.not.required.transitive", "{0} {1} in Modul {2} wird nicht indirekt mit \"requires transitive\" exportiert" },
            { "compiler.warn.leaks.not.accessible.unexported", "{0} {1} in Modul {2} wird nicht exportiert" },
            { "compiler.warn.leaks.not.accessible.unexported.qualified", "{0} {1} in Modul {2} ist m\u00F6glichweise nicht f\u00FCr alle Clients, die dieses Modul ben\u00F6tigen, sichtbar" },
            { "compiler.warn.lintOption", "[{0}] " },
            { "compiler.warn.local.redundant.type", "Redundanter Typ f\u00FCr lokale Variable (ersetzen Sie den expliziten Typ durch \"var\")." },
            { "compiler.warn.locn.unknown.file.on.module.path", "Unbekannte Datei in Modulpfad: {0}" },
            { "compiler.warn.long.SVUID", "serialVersionUID muss den Typ \"long\" in Klasse {0} aufweisen" },
            { "compiler.warn.method.redundant.typeargs", "Redundante Typargumente in Methodenaufruf." },
            { "compiler.warn.missing-explicit-ctor", "Klasse {0} in exportiertem Package {1} deklariert keine expliziten Konstruktoren und stellt daher einen Standardkonstruktor f\u00FCr Clients des Moduls {2} bereit" },
            { "compiler.warn.missing.SVUID", "Serialisierbare Klasse {0} enth\u00E4lt keine Definition von serialVersionUID" },
            { "compiler.warn.missing.deprecated.annotation", "Veraltetes Element ist nicht mit @Deprecated-Annotation versehen" },
            { "compiler.warn.module.for.option.not.found", "Modulname in {0}-Option nicht gefunden: {1}" },
            { "compiler.warn.module.not.found", "Modul nicht gefunden: {0}" },
            { "compiler.warn.non.private.method.weaker.access", "Serialisierungsbezogene Methode, die in einer Schnittstelle als nicht privat deklariert ist, verhindert,\ndass Klassen, die die Schnittstelle implementieren, die Methode als privat deklarieren" },
            { "compiler.warn.non.serializable.instance.field", "Nicht transientes Instanzfeld einer serialisierbaren Klasse mit einem nicht serialisierbaren Typ deklariert" },
            { "compiler.warn.non.serializable.instance.field.array", "Nicht transientes Instanzfeld einer serialisierbaren Klasse wurde mit einem Array mit einem nicht serialisierbaren Basiskomponententyp {0} deklariert" },
            { "compiler.warn.option.obsolete.source", "Quellwert {0} ist veraltet und wird in einem zuk\u00FCnftigen Release entfernt" },
            { "compiler.warn.option.obsolete.suppression", "Verwenden Sie -Xlint:-options, um Warnungen zu veralteten Optionen zu unterdr\u00FCcken." },
            { "compiler.warn.option.obsolete.target", "Zielwert {0} ist veraltet und wird in einem zuk\u00FCnftigen Release entfernt" },
            { "compiler.warn.outdir.is.in.exploded.module", "Das Ausgabeverzeichnis befindet sich in einem entpackten Modul: {0}" },
            { "compiler.warn.output.file.clash", "Ausgabedatei mehrmals geschrieben: {0}" },
            { "compiler.warn.override.bridge", "{0}. Au\u00DFer Kraft setzende Methode ist eine Bridgemethode" },
            { "compiler.warn.override.equals.but.not.hashcode", "Klasse {0} setzt Gleichwertige au\u00DFer Kraft. hashCode-Methode wird aber weder von der Klasse noch einer Superklasse au\u00DFer Kraft gesetzt" },
            { "compiler.warn.override.unchecked.ret", "{0}\nR\u00FCckgabetyp erfordert eine nicht gepr\u00FCfte Konvertierung von {1} in {2}" },
            { "compiler.warn.override.unchecked.thrown", "{0}\nAu\u00DFer Kraft gesetzte Methode l\u00F6st nicht {1} aus" },
            { "compiler.warn.override.varargs.extra", "{0}. In au\u00DFer Kraft setzender Methode fehlt \"...\"" },
            { "compiler.warn.override.varargs.missing", "{0}. Au\u00DFer Kraft gesetzte Methode umfasst kein \"...\"" },
            { "compiler.warn.package.empty.or.not.found", "Package ist leer oder nicht vorhanden: {0}" },
            { "compiler.warn.path.element.not.found", "Ung\u00FCltiges Pfadelement \"{0}\": Datei oder Verzeichnis nicht vorhanden" },
            { "compiler.warn.pkg-info.already.seen", "Die Datei package-info.java wurde bereits f\u00FCr Package {0} gefunden" },
            { "compiler.warn.poor.choice.for.module.name", "Modulnamenskomponente {0} darf keine Ziffern am Ende enthalten" },
            { "compiler.warn.position.overflow", "Positionscodierungs\u00FCberlauf bei Zeile {0}" },
            { "compiler.warn.possible.fall-through.into.case", "M\u00F6glicher Fallthrough in Case" },
            { "compiler.warn.possible.loss.of.precision", "M\u00F6glicher Verlust eines impliziten Cast von {0} bis {1} in zusammengesetzter Zuweisung" },
            { "compiler.warn.possible.this.escape", "M\u00F6gliches \"this\"-Escape vor vollst\u00E4ndiger Initialisierung der Unterklasse" },
            { "compiler.warn.possible.this.escape.location", "Vorheriges m\u00F6gliches \"This\"-Escape erfolgt hier per Aufruf" },
            { "compiler.warn.potential.lambda.found", "Die Erstellung dieser anonymen inneren Klasse kann in einen Lambda-Ausdruck umgewandelt werden." },
            { "compiler.warn.potentially.ambiguous.overload", "{0} in {1} ist m\u00F6glicherweise mehrdeutig mit {2} in {3}" },
            { "compiler.warn.preview.feature.use", "{0} ist ein Vorschaufeature, das in einem zuk\u00FCnftigen Release entfernt werden kann." },
            { "compiler.warn.preview.feature.use.classfile", "Klassendatei f\u00FCr {0} verwendet Vorschaufeatures von Java SE {1}." },
            { "compiler.warn.preview.feature.use.plural", "{0} sind ein Vorschaufeature, das in einem zuk\u00FCnftigen Release entfernt werden kann." },
            { "compiler.warn.prob.found.req", "{0}\nErforderlich: {2}\nErmittelt:    {1}" },
            { "compiler.warn.proc.annotations.without.processors", "Diese Annotationen wurden von keinem Prozessor beansprucht: {0}" },
            { "compiler.warn.proc.duplicate.option.name", "Doppelte unterst\u00FCtzte Option \"{0}\" von Annotationsprozessor \"{1}\" zur\u00FCckgegeben" },
            { "compiler.warn.proc.duplicate.supported.annotation", "Doppelte unterst\u00FCtzte Annotationsschnittstelle \"{0}\" von Annotationsprozessor \"{1}\" zur\u00FCckgegeben" },
            { "compiler.warn.proc.file.create.last.round", "Datei f\u00FCr Typ \"{0}\", die in der letzten Runde erstellt wurde, wird keiner Annotationsverarbeitung unterzogen." },
            { "compiler.warn.proc.file.reopening", "Versuch, mehrmals eine Datei f\u00FCr \"{0}\" zu erstellen" },
            { "compiler.warn.proc.illegal.file.name", "Datei kann nicht f\u00FCr unzul\u00E4ssigen Namen \"{0}\" erstellt werden." },
            { "compiler.warn.proc.malformed.supported.string", "Nicht wohlgeformte Zeichenfolge \"{0}\" f\u00FCr eine unterst\u00FCtzte Annotationsschnittstelle von Prozessor \"{1}\" zur\u00FCckgegeben" },
            { "compiler.warn.proc.messager", "{0}" },
            { "compiler.warn.proc.package.does.not.exist", "Package {0} ist nicht vorhanden" },
            { "compiler.warn.proc.proc-only.requested.no.procs", "Annotationsverarbeitung ohne Kompilierung angefordert, aber keine Prozessoren gefunden." },
            { "compiler.warn.proc.processor.incompatible.source.version", "Unterst\u00FCtzte Quellversion \"{0}\" von Annotationsprozessor \"{1}\" kleiner als -source \"{2}\"" },
            { "compiler.warn.proc.redundant.types.with.wildcard", "Annotationsprozessor \"{0}\" unterst\u00FCtzt redundant sowohl \"*\" als auch andere Annotationsschnittstellen" },
            { "compiler.warn.proc.suspicious.class.name", "Datei f\u00FCr einen Typ, dessen Name mit {1} endet, wird erstellt: \"{0}\"" },
            { "compiler.warn.proc.type.already.exists", "Es ist bereits eine Datei f\u00FCr Typ \"{0}\" im Quellpfad oder Classpath vorhanden" },
            { "compiler.warn.proc.type.recreate", "Versuch, mehrmals eine Datei f\u00FCr Typ \"{0}\" zu erstellen" },
            { "compiler.warn.proc.unclosed.type.files", "Nicht geschlossene Dateien f\u00FCr die Typen \"{0}\". Diese Typen werden keiner Annotationsverarbeitung unterzogen" },
            { "compiler.warn.proc.unmatched.processor.options", "Die folgenden Optionen wurden von keinem Prozessor erkannt: \"{0}\"" },
            { "compiler.warn.proc.use.implicit", "Implizit kompilierte Dateien wurden keiner Annotationsverarbeitung unterzogen.\nVerwenden Sie -implicit, um eine Policy f\u00FCr die implizite Kompilierung anzugeben." },
            { "compiler.warn.proc.use.proc.or.implicit", "Implizit kompilierte Dateien wurden keiner Annotationsverarbeitung unterzogen.\nVerwenden Sie -proc:none, um die Annotationsverarbeitung zu deaktivieren, oder -implicit, um eine Policy f\u00FCr die implizite Kompilierung anzugeben." },
            { "compiler.warn.profile.target.conflict", "Profil {0} ist f\u00FCr Zielrelease {1} nicht g\u00FCltig" },
            { "compiler.warn.raw.class.use", "Raw-Typ gefunden: {0}\nTypargumente f\u00FCr generische Klasse {1} fehlen" },
            { "compiler.warn.redundant.cast", "Redundantes Casting in {0}" },
            { "compiler.warn.requires.automatic", "Erfordert Direktive f\u00FCr ein automatisches Modul" },
            { "compiler.warn.requires.transitive.automatic", "Erfordert transitive-Direktive f\u00FCr ein automatisches Modul" },
            { "compiler.warn.restricted.type.not.allowed", "Ab Release {1} ist \"{0}\" ein eingeschr\u00E4nkter Typname, der nicht f\u00FCr Typdeklarationen oder als Elementtyp eines Arrays verwendet werden kann" },
            { "compiler.warn.restricted.type.not.allowed.preview", "\"{0}\" kann in einem zuk\u00FCnftigen Release ein eingeschr\u00E4nkter Typname werden, der nicht f\u00FCr Typdeklarationen oder als Elementtyp eines Arrays verwendet werden kann" },
            { "compiler.warn.self.ref", "Selbstreferenz in Initializer von Variable \"{0}\"" },
            { "compiler.warn.serial.concrete.instance.method", "Serialisierungsbezogene Methode {0} muss eine konkrete Instanzmethode sein, um in Kraft zu treten. Sie darf nicht abstrakt oder statisch sein" },
            { "compiler.warn.serial.method.no.args", "Serialisierungsbezogene Methode {0} darf keine Parameter aufweisen, um in Kraft zu treten" },
            { "compiler.warn.serial.method.not.private", "Serialisierungsbezogene Methode {0} nicht als privat deklariert" },
            { "compiler.warn.serial.method.one.arg", "Serialisierungsbezogene Methode {0} muss genau einen Parameter aufweisen, um in Kraft zu treten. Sie darf nicht {1} Parameter enthalten" },
            { "compiler.warn.serial.method.parameter.type", "Der einzige Parameter der serialisierungsbezogenen Methode {0} muss den Typ {1} haben, um in Kraft zu treten. Er darf nicht den Typ {2} aufweisen" },
            { "compiler.warn.serial.method.static", "Serialisierungsbezogene Methode {0} ist als statisch deklariert. Sie muss stattdessen eine Instanzmethode sein, um in Kraft zu treten." },
            { "compiler.warn.serial.method.unexpected.exception", "Serialisierungsbezogene Methode {0} wurde zum Ausl\u00F6sen eines unerwarteten Typs {1} deklariert" },
            { "compiler.warn.serial.method.unexpected.return.type", "Serialisierungsbezogene Methode {0} wurde mit dem R\u00FCckgabetyp {1} und nicht dem erwarteten Typ {2} deklariert.\nMit dieser Deklaration ist die Methode ung\u00FCltig f\u00FCr die Serialisierung" },
            { "compiler.warn.serializable.missing.access.no.arg.ctor", "Zugriff auf einen no-arg-Konstruktor in der ersten nicht serialisierbaren Superklasse {0} nicht m\u00F6glich" },
            { "compiler.warn.service.provided.but.not.exported.or.used", "Serviceschnittstelle angegeben, aber nicht exportiert oder verwendet" },
            { "compiler.warn.source.no.bootclasspath", "Bootstrap Classpath nicht zusammen mit -source {0} festgelegt" },
            { "compiler.warn.source.no.system.modules.path", "Systemmodulpfad nicht zusammen mit -source {0} festgelegt" },
            { "compiler.warn.source.target.conflict", "Quellrelease {0} erfordert Zielrelease {1}" },
            { "compiler.warn.static.not.qualified.by.type", "Statische {0} muss mit Typname {1} anstelle eines Ausdrucks qualifiziert werden" },
            { "compiler.warn.static.not.qualified.by.type2", "{0} (statisch) darf nicht als Member einer anonymen Klasse verwendet werden" },
            { "compiler.warn.strictfp", "Ab Release 17 werden alle Gleitkommaausdr\u00FCcke streng ausgewertet. Daher ist \"strictfp\" nicht erforderlich" },
            { "compiler.warn.sun.proprietary", "{0} ist eine interne propriet\u00E4re API, die in einem zuk\u00FCnftigen Release entfernt werden kann" },
            { "compiler.warn.target.default.source.conflict", "Zielrelease {0} steht mit Standardquellrelease {1} in Konflikt" },
            { "compiler.warn.trailing.white.space.will.be.removed", "Nachgestelltes Leerzeichen wird entfernt" },
            { "compiler.warn.try.explicit.close.call", "Expliziter Aufruf von close() f\u00FCr eine automatisch schlie\u00DFbare Ressource" },
            { "compiler.warn.try.resource.not.referenced", "Automatisch schlie\u00DFbare Ressource {0} wird nie im Body der entsprechenden try-Anweisung referenziert" },
            { "compiler.warn.try.resource.throws.interrupted.exc", "Automatisch schlie\u00DFbare Ressource {0} umfasst die Mitgliedsmethode close(), die InterruptedException ausl\u00F6sen k\u00F6nnte" },
            { "compiler.warn.unchecked.assign", "Nicht gepr\u00FCfte Zuweisung: {0} zu {1}" },
            { "compiler.warn.unchecked.assign.to.var", "Nicht gepr\u00FCfte Zuweisung zu Variable {0} als Mitglied des Raw-Typs {1}" },
            { "compiler.warn.unchecked.call.mbr.of.raw.type", "Nicht gepr\u00FCfter Aufruf von {0} als Mitglied des Raw-Typs {1}" },
            { "compiler.warn.unchecked.cast.to.type", "Nicht gepr\u00FCftes Casting zu Typ {0}" },
            { "compiler.warn.unchecked.generic.array.creation", "Nicht gepr\u00FCfte Erstellung eines generischen Arrays f\u00FCr varargs-Parameter des Typs {0}" },
            { "compiler.warn.unchecked.meth.invocation.applied", "Nicht gepr\u00FCfter Methodenaufruf: {0} {1} in {4} {5} wird auf die angegebenen Typen angewendet\nErforderlich: {2}\nErmittelt:    {3}" },
            { "compiler.warn.unchecked.varargs.non.reifiable.type", "M\u00F6glich Heap-Besch\u00E4digung aus parametrisiertem vararg-Typ {0}" },
            { "compiler.warn.underscore.as.identifier", "Ab Release 9 ist \"_\" ein Schl\u00FCsselwort und kann nicht als ID verwendet werden" },
            { "compiler.warn.unexpected.archive.file", "Unerwartete Erweiterung f\u00FCr Archivdatei: {0}" },
            { "compiler.warn.unknown.enum.constant", "Unbekannte Enum-Konstante {1}.{2}" },
            { "compiler.warn.unknown.enum.constant.reason", "Unbekannte Enum-Konstante {1}.{2}\nGrund: {3}" },
            { "compiler.warn.unreachable.catch", "Nicht erreichbare Catch-Klausel\nAusgel\u00F6ster Typ {0} wurde bereits abgefangen" },
            { "compiler.warn.unreachable.catch.1", "Nicht erreichbare Catch-Klausel\nAusgel\u00F6ste Typen {0} wurden bereits abgefangen" },
            { "compiler.warn.varargs.redundant.trustme.anno", "Redundante {0}-Annotation. {1}" },
            { "compiler.warn.varargs.unsafe.use.varargs.param", "Varargs-Methode k\u00F6nnte Heap-Besch\u00E4digung aus nicht reifizierbarem varargs-Parameter {0} verursachen" },
            { "compiler.warn.warning", "Warnung: " },
        };
    }
}
